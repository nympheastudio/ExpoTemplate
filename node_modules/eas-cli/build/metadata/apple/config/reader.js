"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppleConfigReader = exports.DEFAULT_WHATSNEW = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const uniq_1 = tslib_1.__importDefault(require("../../../utils/expodash/uniq"));
const date_1 = require("../../utils/date");
// TODO: find out if we can move this to default JSON schema normalization
exports.DEFAULT_WHATSNEW = 'Bug fixes and improved stability';
/**
 * Deserializes the metadata config schema into attributes for different models.
 * This uses version 0 of the config schema.
 */
class AppleConfigReader {
    constructor(schema) {
        this.schema = schema;
    }
    getAgeRating() {
        const attributes = this.schema.advisory;
        if (!attributes) {
            return null;
        }
        return {
            alcoholTobaccoOrDrugUseOrReferences: attributes.alcoholTobaccoOrDrugUseOrReferences ?? apple_utils_1.Rating.NONE,
            contests: attributes.contests ?? apple_utils_1.Rating.NONE,
            gamblingSimulated: attributes.gamblingSimulated ?? apple_utils_1.Rating.NONE,
            horrorOrFearThemes: attributes.horrorOrFearThemes ?? apple_utils_1.Rating.NONE,
            matureOrSuggestiveThemes: attributes.matureOrSuggestiveThemes ?? apple_utils_1.Rating.NONE,
            medicalOrTreatmentInformation: attributes.medicalOrTreatmentInformation ?? apple_utils_1.Rating.NONE,
            profanityOrCrudeHumor: attributes.profanityOrCrudeHumor ?? apple_utils_1.Rating.NONE,
            sexualContentGraphicAndNudity: attributes.sexualContentGraphicAndNudity ?? apple_utils_1.Rating.NONE,
            sexualContentOrNudity: attributes.sexualContentOrNudity ?? apple_utils_1.Rating.NONE,
            violenceCartoonOrFantasy: attributes.violenceCartoonOrFantasy ?? apple_utils_1.Rating.NONE,
            violenceRealistic: attributes.violenceRealistic ?? apple_utils_1.Rating.NONE,
            violenceRealisticProlongedGraphicOrSadistic: attributes.violenceRealisticProlongedGraphicOrSadistic ?? apple_utils_1.Rating.NONE,
            gambling: attributes.gambling ?? false,
            unrestrictedWebAccess: attributes.unrestrictedWebAccess ?? false,
            kidsAgeBand: attributes.kidsAgeBand ?? null,
            seventeenPlus: attributes.seventeenPlus ?? false,
        };
    }
    getLocales() {
        // TODO: filter "default" locales, add option to add non-localized info to the config
        return (0, uniq_1.default)(Object.keys(this.schema.info || {}));
    }
    getInfoLocale(locale) {
        const info = this.schema.info?.[locale];
        if (!info) {
            return null;
        }
        return {
            locale,
            name: info.title,
            subtitle: info.subtitle,
            privacyChoicesUrl: info.privacyChoicesUrl,
            privacyPolicyText: info.privacyPolicyText,
            privacyPolicyUrl: info.privacyPolicyUrl,
        };
    }
    getCategories() {
        const { categories } = this.schema;
        if (!categories || categories.length <= 0) {
            return null;
        }
        // We validate the categories based on enums, but they will still be strings here.
        const categoryIds = {};
        if (Array.isArray(categories[0])) {
            categoryIds.primaryCategory = categories[0][0];
            categoryIds.primarySubcategoryOne = categories[0][1];
            categoryIds.primarySubcategoryTwo = categories[0][2];
        }
        else {
            categoryIds.primaryCategory = categories[0];
        }
        if (Array.isArray(categories[1])) {
            categoryIds.secondaryCategory = categories[1][0];
            categoryIds.secondarySubcategoryOne = categories[1][1];
            categoryIds.secondarySubcategoryTwo = categories[1][2];
        }
        else {
            categoryIds.secondaryCategory = categories[1];
        }
        // Because we handle categories as normal strings,
        // the type doesn't match with the actual CategoryIds types.
        return categoryIds;
    }
    /** Get the `AppStoreVersion` object. */
    getVersion() {
        const attributes = {
            versionString: this.schema.version ?? '',
            copyright: this.schema.copyright ?? null,
        };
        const hasValues = Object.values(attributes).some(Boolean);
        return hasValues ? attributes : null;
    }
    getVersionReleaseType() {
        const { release } = this.schema;
        if (typeof release?.automaticRelease === 'string') {
            return {
                releaseType: apple_utils_1.ReleaseType.SCHEDULED,
                // Convert time format to 2020-06-17T12:00:00-07:00, if that fails, try the date anyways.
                earliestReleaseDate: (0, date_1.removeDatePrecision)(release.automaticRelease)?.toISOString() ?? release.automaticRelease,
            };
        }
        if (release?.automaticRelease === true) {
            return {
                releaseType: apple_utils_1.ReleaseType.AFTER_APPROVAL,
                earliestReleaseDate: null,
            };
        }
        if (release?.automaticRelease === false) {
            return {
                releaseType: apple_utils_1.ReleaseType.MANUAL,
                earliestReleaseDate: null,
            };
        }
        return null;
    }
    getVersionReleasePhased() {
        if (this.schema.release?.phasedRelease === true) {
            return {
                phasedReleaseState: apple_utils_1.PhasedReleaseState.ACTIVE,
            };
        }
        // When phased release is turned off, we need to delete the phased release request.
        // There is no concept (yet) of pausing the phased release through EAS metadata.
        return null;
    }
    getVersionLocale(locale, context) {
        const info = this.schema.info?.[locale];
        if (!info) {
            return null;
        }
        return {
            locale,
            description: info.description,
            keywords: info.keywords?.join(','),
            // TODO: maybe move this to task logic, it's more an exception than data handling
            whatsNew: context.versionIsFirst ? undefined : info.releaseNotes || exports.DEFAULT_WHATSNEW,
            marketingUrl: info.marketingUrl,
            promotionalText: info.promoText,
            supportUrl: info.supportUrl,
        };
    }
    getReviewDetails() {
        const review = this.schema.review;
        if (!review) {
            return null;
        }
        return {
            contactFirstName: review.firstName,
            contactLastName: review.lastName,
            contactEmail: review.email,
            contactPhone: review.phone,
            demoAccountName: review.demoUsername,
            demoAccountPassword: review.demoPassword,
            demoAccountRequired: review.demoRequired,
            notes: review.notes,
            // TODO: add attachment
        };
    }
}
exports.AppleConfigReader = AppleConfigReader;
