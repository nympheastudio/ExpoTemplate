"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const eas_json_1 = require("@expo/eas-json");
const BuildCredentialsUtils_1 = require("./actions/BuildCredentialsUtils");
const SetUpBuildCredentials_1 = require("./actions/SetUpBuildCredentials");
const SetUpPushKey_1 = require("./actions/SetUpPushKey");
const provisioningProfile_1 = require("./utils/provisioningProfile");
const log_1 = tslib_1.__importDefault(require("../../log"));
const target_1 = require("../../project/ios/target");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const credentialsJsonReader = tslib_1.__importStar(require("../credentialsJson/read"));
const utils_1 = require("../credentialsJson/utils");
var PushNotificationSetupOption;
(function (PushNotificationSetupOption) {
    PushNotificationSetupOption[PushNotificationSetupOption["YES"] = 0] = "YES";
    PushNotificationSetupOption[PushNotificationSetupOption["NO"] = 1] = "NO";
    PushNotificationSetupOption[PushNotificationSetupOption["NO_DONT_ASK_AGAIN"] = 2] = "NO_DONT_ASK_AGAIN";
})(PushNotificationSetupOption || (PushNotificationSetupOption = {}));
class IosCredentialsProvider {
    constructor(ctx, options) {
        this.ctx = ctx;
        this.options = options;
        this.platform = eas_build_job_1.Platform.IOS;
    }
    async getCredentialsAsync(src) {
        let buildCredentials;
        if (src === eas_json_1.CredentialsSource.LOCAL) {
            buildCredentials = await this.getLocalAsync();
        }
        else {
            buildCredentials = await this.getRemoteAsync();
        }
        await this.getPushKeyAsync(this.ctx, this.options.targets);
        return buildCredentials;
    }
    async getLocalAsync() {
        const applicationTarget = (0, target_1.findApplicationTarget)(this.options.targets);
        const iosCredentials = await credentialsJsonReader.readIosCredentialsAsync(this.ctx.projectDir, applicationTarget);
        (0, utils_1.ensureAllTargetsAreConfigured)(this.options.targets, iosCredentials);
        for (const target of this.options.targets) {
            this.assertProvisioningProfileType(iosCredentials[target.targetName].provisioningProfile, target.targetName);
        }
        return iosCredentials;
    }
    async getRemoteAsync() {
        return await new SetUpBuildCredentials_1.SetUpBuildCredentials({
            app: this.options.app,
            targets: this.options.targets,
            distribution: this.options.distribution,
            enterpriseProvisioning: this.options.enterpriseProvisioning,
        }).runAsync(this.ctx);
    }
    async getPushKeyAsync(ctx, targets) {
        if (ctx.nonInteractive) {
            return null;
        }
        const applicationTarget = (0, target_1.findApplicationTarget)(targets);
        const app = await (0, BuildCredentialsUtils_1.getAppFromContextAsync)(ctx);
        const appLookupParams = {
            ...app,
            bundleIdentifier: applicationTarget.bundleIdentifier,
            parentBundleIdentifier: applicationTarget.parentBundleIdentifier,
        };
        const setupPushKeyAction = new SetUpPushKey_1.SetUpPushKey(appLookupParams);
        const isPushKeySetup = await setupPushKeyAction.isPushKeySetupAsync(ctx);
        if (isPushKeySetup) {
            log_1.default.succeed(`Push Notifications setup for ${app.projectName}: ${applicationTarget.bundleIdentifier}`);
            return null;
        }
        if (ctx.easJsonCliConfig?.promptToConfigurePushNotifications === false) {
            return null;
        }
        else if (ctx.easJsonCliConfig?.promptToConfigurePushNotifications === undefined &&
            !(await (0, projectUtils_1.isExpoNotificationsInstalled)(ctx.projectDir))) {
            return null;
        }
        const setupOption = await (0, prompts_1.selectAsync)(`Would you like to set up Push Notifications for your project?`, [
            { title: 'Yes', value: PushNotificationSetupOption.YES },
            { title: 'No', value: PushNotificationSetupOption.NO },
            {
                title: `No, don't ask again (preference will be saved to eas.json)`,
                value: PushNotificationSetupOption.NO_DONT_ASK_AGAIN,
            },
        ]);
        if (setupOption === PushNotificationSetupOption.YES) {
            return await setupPushKeyAction.runAsync(ctx);
        }
        else {
            if (setupOption === PushNotificationSetupOption.NO_DONT_ASK_AGAIN) {
                await this.disablePushNotificationsSetupInEasJsonAsync(ctx);
            }
            return null;
        }
    }
    async disablePushNotificationsSetupInEasJsonAsync(ctx) {
        const easJsonAccessor = eas_json_1.EasJsonAccessor.fromProjectPath(ctx.projectDir);
        await easJsonAccessor.readRawJsonAsync();
        easJsonAccessor.patch(easJsonRawObject => {
            easJsonRawObject.cli = {
                ...easJsonRawObject?.cli,
                promptToConfigurePushNotifications: false,
            };
            return easJsonRawObject;
        });
        await easJsonAccessor.writeAsync();
        log_1.default.withTick('Updated eas.json');
    }
    assertProvisioningProfileType(provisioningProfile, targetName) {
        const isAdHoc = (0, provisioningProfile_1.isAdHocProfile)(provisioningProfile);
        const isEnterprise = (0, provisioningProfile_1.isEnterpriseUniversalProfile)(provisioningProfile);
        if (this.options.distribution === 'internal') {
            if (this.options.enterpriseProvisioning === 'universal' && !isEnterprise) {
                throw new Error(`You must use a universal provisioning profile${targetName ? ` (target '${targetName})'` : ''} for internal distribution if you specified "enterpriseProvisioning": "universal" in eas.json`);
            }
            else if (this.options.enterpriseProvisioning === 'adhoc' && !isAdHoc) {
                throw new Error(`You must use an adhoc provisioning profile${targetName ? ` (target '${targetName})'` : ''} for internal distribution if you specified "enterpriseProvisioning": "adhoc" in eas.json`);
            }
            else if (!this.options.enterpriseProvisioning && !isEnterprise && !isAdHoc) {
                throw new Error(`You must use an adhoc provisioning profile${targetName ? ` (target '${targetName})'` : ''} for internal distribution.`);
            }
        }
        else if (isAdHoc) {
            throw new Error(`You can't use an adhoc provisioning profile${targetName ? ` (target '${targetName}')` : ''} for app store distribution.`);
        }
    }
}
exports.default = IosCredentialsProvider;
