"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doUDIDsMatch = exports.SetUpAdhocProvisioningProfile = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const AppleTeamUtils_1 = require("./AppleTeamUtils");
const BuildCredentialsUtils_1 = require("./BuildCredentialsUtils");
const DeviceUtils_1 = require("./DeviceUtils");
const SetUpDistributionCertificate_1 = require("./SetUpDistributionCertificate");
const action_1 = tslib_1.__importStar(require("../../../devices/actions/create/action"));
const generated_1 = require("../../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const target_1 = require("../../../project/ios/target");
const prompts_1 = require("../../../prompts");
const differenceBy_1 = tslib_1.__importDefault(require("../../../utils/expodash/differenceBy"));
const errors_1 = require("../../errors");
const constants_1 = require("../appstore/constants");
const validateProvisioningProfile_1 = require("../validators/validateProvisioningProfile");
var ReuseAction;
(function (ReuseAction) {
    ReuseAction[ReuseAction["Yes"] = 0] = "Yes";
    ReuseAction[ReuseAction["ShowDevices"] = 1] = "ShowDevices";
    ReuseAction[ReuseAction["No"] = 2] = "No";
})(ReuseAction || (ReuseAction = {}));
class SetUpAdhocProvisioningProfile {
    constructor(options) {
        this.options = options;
    }
    async runAsync(ctx) {
        const { app } = this.options;
        const distCert = await new SetUpDistributionCertificate_1.SetUpDistributionCertificate(app, generated_1.IosDistributionType.AdHoc).runAsync(ctx);
        const areBuildCredentialsSetup = await this.areBuildCredentialsSetupAsync(ctx);
        if (ctx.nonInteractive) {
            if (areBuildCredentialsSetup) {
                return (0, nullthrows_1.default)(await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, app, generated_1.IosDistributionType.AdHoc));
            }
            else {
                throw new errors_1.MissingCredentialsNonInteractiveError('Provisioning profile is not configured correctly. Run this command again in interactive mode.');
            }
        }
        const currentBuildCredentials = await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, app, generated_1.IosDistributionType.AdHoc);
        if (areBuildCredentialsSetup) {
            const buildCredentials = (0, nullthrows_1.default)(currentBuildCredentials);
            if (await this.shouldUseExistingProfileAsync(ctx, buildCredentials)) {
                return buildCredentials;
            }
        }
        return await this.runWithDistributionCertificateAsync(ctx, distCert);
    }
    async runWithDistributionCertificateAsync(ctx, distCert) {
        const { app, target } = this.options;
        const currentBuildCredentials = await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, app, generated_1.IosDistributionType.AdHoc);
        // 1. Resolve Apple Team
        let appleTeam = distCert.appleTeam ?? currentBuildCredentials?.provisioningProfile?.appleTeam ?? null;
        if (!appleTeam) {
            await ctx.appStore.ensureAuthenticatedAsync();
            appleTeam = await (0, AppleTeamUtils_1.resolveAppleTeamIfAuthenticatedAsync)(ctx, app);
        }
        (0, assert_1.default)(appleTeam, 'Apple Team must be defined here');
        // 2. Fetch devices registered on EAS servers
        let registeredAppleDevices = await ctx.ios.getDevicesForAppleTeamAsync(ctx.graphqlClient, app, appleTeam);
        if (registeredAppleDevices.length === 0) {
            const shouldRegisterDevices = await (0, prompts_1.confirmAsync)({
                message: `You don't have any registered devices yet. Would you like to register them now?`,
                initial: true,
            });
            if (shouldRegisterDevices) {
                registeredAppleDevices = await this.registerDevicesAsync(ctx, appleTeam);
            }
            else {
                throw new Error(`Run 'eas device:create' to register your devices first`);
            }
        }
        // 3. Choose devices for internal distribution
        const provisionedDeviceIdentifiers = (currentBuildCredentials?.provisioningProfile?.appleDevices ?? []).map(i => i.identifier);
        const chosenDevices = await (0, DeviceUtils_1.chooseDevicesAsync)(registeredAppleDevices, provisionedDeviceIdentifiers);
        // 4. Reuse or create the profile on Apple Developer Portal
        const applePlatform = await (0, target_1.getApplePlatformFromTarget)(target);
        const profileType = applePlatform === constants_1.ApplePlatform.TV_OS
            ? apple_utils_1.ProfileType.TVOS_APP_ADHOC
            : apple_utils_1.ProfileType.IOS_APP_ADHOC;
        const provisioningProfileStoreInfo = await ctx.appStore.createOrReuseAdhocProvisioningProfileAsync(chosenDevices.map(({ identifier }) => identifier), app.bundleIdentifier, distCert.serialNumber, profileType);
        // 5. Create or update the profile on servers
        const appleAppIdentifier = await ctx.ios.createOrGetExistingAppleAppIdentifierAsync(ctx.graphqlClient, app, appleTeam);
        let appleProvisioningProfile;
        if (currentBuildCredentials?.provisioningProfile) {
            appleProvisioningProfile = await this.reuseCurrentProvisioningProfileAsync(currentBuildCredentials.provisioningProfile, provisioningProfileStoreInfo, ctx, app, appleAppIdentifier);
        }
        else {
            appleProvisioningProfile = await ctx.ios.createProvisioningProfileAsync(ctx.graphqlClient, app, appleAppIdentifier, {
                appleProvisioningProfile: provisioningProfileStoreInfo.provisioningProfile,
                developerPortalIdentifier: provisioningProfileStoreInfo.provisioningProfileId,
            });
        }
        // 6. Compare selected devices with the ones actually provisioned
        const diffList = (0, differenceBy_1.default)(chosenDevices, appleProvisioningProfile.appleDevices, 'identifier');
        if (diffList.length > 0) {
            log_1.default.warn(`Failed to provision ${diffList.length} of the selected devices:`);
            for (const missingDevice of diffList) {
                log_1.default.warn(`- ${(0, DeviceUtils_1.formatDeviceLabel)(missingDevice)}`);
            }
            log_1.default.log('Most commonly devices fail to to be provisioned while they are still being processed by Apple, which can take up to 24-72 hours. Check your Apple Developer Portal page at https://developer.apple.com/account/resources/devices/list, the devices in "Processing" status cannot be provisioned yet');
            const shouldContinue = await (0, prompts_1.selectAsync)('Do you want to continue without provisioning these devices?', [
                {
                    title: 'Yes',
                    value: true,
                },
                {
                    title: 'No (EAS CLI will exit)',
                    value: false,
                },
            ]);
            if (!shouldContinue) {
                core_1.Errors.exit(1);
            }
        }
        // 7. Create (or update) app build credentials
        (0, assert_1.default)(appleProvisioningProfile);
        return await (0, BuildCredentialsUtils_1.assignBuildCredentialsAsync)(ctx, app, generated_1.IosDistributionType.AdHoc, distCert, appleProvisioningProfile, appleTeam);
    }
    async reuseCurrentProvisioningProfileAsync(currentProvisioningProfile, provisioningProfileStoreInfo, ctx, app, appleAppIdentifier) {
        if (currentProvisioningProfile.developerPortalIdentifier !==
            provisioningProfileStoreInfo.provisioningProfileId) {
            // If IDs don't match, the profile needs to be deleted and re-created
            await ctx.ios.deleteProvisioningProfilesAsync(ctx.graphqlClient, [
                currentProvisioningProfile.id,
            ]);
            return await ctx.ios.createProvisioningProfileAsync(ctx.graphqlClient, app, appleAppIdentifier, {
                appleProvisioningProfile: provisioningProfileStoreInfo.provisioningProfile,
                developerPortalIdentifier: provisioningProfileStoreInfo.provisioningProfileId,
            });
        }
        else {
            // If not, the profile needs to be updated first
            return await ctx.ios.updateProvisioningProfileAsync(ctx.graphqlClient, currentProvisioningProfile.id, {
                appleProvisioningProfile: provisioningProfileStoreInfo.provisioningProfile,
                developerPortalIdentifier: provisioningProfileStoreInfo.provisioningProfileId,
            });
        }
    }
    async areBuildCredentialsSetupAsync(ctx) {
        const { app, target } = this.options;
        const buildCredentials = await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, app, generated_1.IosDistributionType.AdHoc);
        return await (0, validateProvisioningProfile_1.validateProvisioningProfileAsync)(ctx, target, app, buildCredentials);
    }
    async shouldUseExistingProfileAsync(ctx, buildCredentials) {
        const { app } = this.options;
        const provisioningProfile = (0, nullthrows_1.default)(buildCredentials.provisioningProfile);
        const appleTeam = (0, nullthrows_1.default)(provisioningProfile.appleTeam);
        const registeredAppleDevices = await ctx.ios.getDevicesForAppleTeamAsync(ctx.graphqlClient, app, appleTeam);
        const provisionedDevices = provisioningProfile.appleDevices;
        const allRegisteredDevicesAreProvisioned = doUDIDsMatch(registeredAppleDevices.map(({ identifier }) => identifier), provisionedDevices.map(({ identifier }) => identifier));
        if (allRegisteredDevicesAreProvisioned) {
            const reuseAction = await this.promptForReuseActionAsync();
            if (reuseAction === ReuseAction.Yes) {
                return true;
            }
            else if (reuseAction === ReuseAction.No) {
                return false;
            }
            else {
                log_1.default.newLine();
                log_1.default.log('Devices registered in the Provisioning Profile:');
                for (const device of provisionedDevices) {
                    log_1.default.log(`- ${(0, DeviceUtils_1.formatDeviceLabel)(device)}`);
                }
                log_1.default.newLine();
                return ((await this.promptForReuseActionAsync({ showShowDevicesOption: false })) ===
                    ReuseAction.Yes);
            }
        }
        else {
            const missingDevices = (0, differenceBy_1.default)(registeredAppleDevices, provisionedDevices, 'identifier');
            log_1.default.warn(`The provisioning profile is missing the following devices:`);
            for (const missingDevice of missingDevices) {
                log_1.default.warn(`- ${(0, DeviceUtils_1.formatDeviceLabel)(missingDevice)}`);
            }
            return !(await (0, prompts_1.confirmAsync)({
                message: `Would you like to choose the devices to provision again?`,
                initial: true,
            }));
        }
    }
    async promptForReuseActionAsync({ showShowDevicesOption = true, } = {}) {
        const { selected } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'selected',
            message: `${showShowDevicesOption
                ? 'All your registered devices are present in the Provisioning Profile. '
                : ''}Would you like to reuse the profile?`,
            choices: [
                { title: 'Yes', value: ReuseAction.Yes },
                ...(showShowDevicesOption
                    ? [
                        {
                            title: 'Show devices and ask me again',
                            value: ReuseAction.ShowDevices,
                        },
                    ]
                    : []),
                {
                    title: 'No, let me choose devices again',
                    value: ReuseAction.No,
                },
            ],
        });
        return selected;
    }
    async registerDevicesAsync(ctx, appleTeam) {
        const { app } = this.options;
        const action = new action_1.default(ctx.graphqlClient, ctx.appStore, app.account, appleTeam);
        const method = await action.runAsync();
        while (true) {
            if (method === action_1.RegistrationMethod.WEBSITE) {
                log_1.default.log(chalk_1.default.bold("Press any key if you've already finished device registration."));
                await (0, prompts_1.pressAnyKeyToContinueAsync)();
            }
            log_1.default.newLine();
            const devices = await ctx.ios.getDevicesForAppleTeamAsync(ctx.graphqlClient, app, appleTeam, {
                useCache: false,
            });
            if (devices.length === 0) {
                log_1.default.warn('There are still no registered devices.');
                // if the user used the input method there should be some devices available
                if (method === action_1.RegistrationMethod.INPUT) {
                    throw new Error('Input registration method has failed');
                }
            }
            else {
                return devices;
            }
        }
    }
}
exports.SetUpAdhocProvisioningProfile = SetUpAdhocProvisioningProfile;
function doUDIDsMatch(udidsA, udidsB) {
    const setA = new Set(udidsA);
    const setB = new Set(udidsB);
    if (setA.size !== setB.size) {
        return false;
    }
    for (const a of setA) {
        if (!setB.has(a)) {
            return false;
        }
    }
    return true;
}
exports.doUDIDsMatch = doUDIDsMatch;
