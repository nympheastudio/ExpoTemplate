"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureAppExistsAsync = exports.syncCapabilityIdentifiersAsync = exports.syncCapabilitiesAsync = exports.ensureBundleIdExistsWithNameAsync = exports.ensureBundleIdExistsAsync = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const authenticate_1 = require("./authenticate");
const bundleIdCapabilities_1 = require("./bundleIdCapabilities");
const capabilityIdentifiers_1 = require("./capabilityIdentifiers");
const contractMessages_1 = require("./contractMessages");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const ora_1 = require("../../../ora");
async function ensureBundleIdExistsAsync(authCtx, { accountName, projectName, bundleIdentifier }, options) {
    return ensureBundleIdExistsWithNameAsync(authCtx, {
        name: `@${accountName}/${projectName}`,
        bundleIdentifier,
    }, options);
}
exports.ensureBundleIdExistsAsync = ensureBundleIdExistsAsync;
async function ensureBundleIdExistsWithNameAsync(authCtx, { name, bundleIdentifier }, options) {
    const context = (0, authenticate_1.getRequestContext)(authCtx);
    const spinner = (0, ora_1.ora)(`Linking bundle identifier ${chalk_1.default.dim(bundleIdentifier)}`).start();
    let bundleId;
    try {
        // Get the bundle id
        bundleId = await apple_utils_1.BundleId.findAsync(context, { identifier: bundleIdentifier });
        if (!bundleId) {
            spinner.text = `Registering bundle identifier ${chalk_1.default.dim(bundleIdentifier)}`;
            // If it doesn't exist, create it
            bundleId = await apple_utils_1.BundleId.createAsync(context, {
                name,
                identifier: bundleIdentifier,
            });
        }
        spinner.succeed(`Bundle identifier registered ${chalk_1.default.dim(bundleIdentifier)}`);
    }
    catch (err) {
        if (err.message.match(/An App ID with Identifier '(.*)' is not available/)) {
            spinner.fail(`The bundle identifier ${chalk_1.default.bold(bundleIdentifier)} is not available to team "${authCtx.team.name}" (${authCtx.team.id}), change it in your app config and try again.`);
        }
        else {
            spinner.fail(`Failed to register bundle identifier ${chalk_1.default.dim(bundleIdentifier)}`);
            // Assert contract errors for easier resolution when the user has an expired developer account.
            if (err.message.match(/forbidden for security reasons/) ||
                // Unable to process request - PLA Update available - You currently don't have access to this membership resource. To resolve this issue, agree to the latest Program License Agreement in your developer account.
                err.message.match(/agree/)) {
                if ((0, authenticate_1.isUserAuthCtx)(authCtx)) {
                    await (0, contractMessages_1.assertContractMessagesAsync)(context);
                }
                else {
                    log_1.default.warn(`You currently don't have access to this membership resource. To resolve this issue, agree to the latest Program License Agreement in your developer account.`);
                }
            }
        }
        throw err;
    }
    if (options) {
        await syncCapabilitiesAsync(bundleId, options);
    }
}
exports.ensureBundleIdExistsWithNameAsync = ensureBundleIdExistsWithNameAsync;
async function syncCapabilitiesAsync(bundleId, { entitlements }) {
    const spinner = (0, ora_1.ora)(`Syncing capabilities`).start();
    // Stop spinning in debug mode so we can print other information
    if (log_1.default.isDebug) {
        spinner.stop();
    }
    try {
        const { enabled, disabled } = await (0, bundleIdCapabilities_1.syncCapabilitiesForEntitlementsAsync)(bundleId, entitlements);
        const results = [buildMessage('Enabled', enabled), buildMessage('Disabled', disabled)]
            .filter(Boolean)
            .join(' | ') || 'No updates';
        spinner.succeed(`Synced capabilities: ` + chalk_1.default.dim(results));
    }
    catch (err) {
        spinner.fail(`Failed to sync capabilities ${chalk_1.default.dim(bundleId.attributes.identifier)}`);
        throw err;
    }
    // Always run this after syncing the capabilities...
    await syncCapabilityIdentifiersAsync(bundleId, { entitlements });
}
exports.syncCapabilitiesAsync = syncCapabilitiesAsync;
const buildMessage = (title, items) => items.length ? `${title}: ${items.join(', ')}` : '';
async function syncCapabilityIdentifiersAsync(bundleId, { entitlements }) {
    const spinner = (0, ora_1.ora)(`Syncing capabilities identifiers`).start();
    // Stop spinning in debug mode so we can print other information
    if (log_1.default.isDebug) {
        spinner.stop();
    }
    try {
        const { created, linked } = await (0, capabilityIdentifiers_1.syncCapabilityIdentifiersForEntitlementsAsync)(bundleId, entitlements);
        const results = [buildMessage('Created', created), buildMessage('Linked', linked)]
            .filter(Boolean)
            .join(' | ') || 'No updates';
        spinner.succeed(`Synced capability identifiers: ` + chalk_1.default.dim(results));
    }
    catch (err) {
        spinner.fail(`Failed to sync capability identifiers ${chalk_1.default.dim(bundleId.attributes.identifier)}`);
        throw err;
    }
}
exports.syncCapabilityIdentifiersAsync = syncCapabilityIdentifiersAsync;
async function ensureAppExistsAsync(userAuthCtx, { name, language, companyName, bundleIdentifier, sku, }) {
    const context = (0, authenticate_1.getRequestContext)(userAuthCtx);
    const spinner = (0, ora_1.ora)(`Linking to App Store Connect ${chalk_1.default.dim(bundleIdentifier)}`).start();
    let app = await apple_utils_1.App.findAsync(context, { bundleId: bundleIdentifier });
    if (!app) {
        spinner.text = `Creating App Store Connect app ${chalk_1.default.bold(name)} ${chalk_1.default.dim(bundleIdentifier)}`;
        try {
            // Assert contract errors when the user needs to create an app.
            await (0, contractMessages_1.assertContractMessagesAsync)(context, spinner);
            /**
             * **Does not support App Store Connect API (CI).**
             */
            app = await apple_utils_1.App.createAsync(context, {
                bundleId: bundleIdentifier,
                name,
                primaryLocale: language,
                companyName,
                sku,
            });
        }
        catch (error) {
            if (error.message.match(/An App ID with Identifier '(.*)' is not available/)) {
                throw new Error(`\nThe bundle identifier "${bundleIdentifier}" is not available to provider "${userAuthCtx.authState?.session.provider.name}. Change it in your app config and try again.\n`);
            }
            spinner.fail(`Failed to create App Store app ${chalk_1.default.dim(name)}`);
            error.message +=
                '\nVisit https://appstoreconnect.apple.com and resolve any warnings, then try again.';
            throw error;
        }
    }
    else {
        // TODO: Update app name when API gives us that possibility
    }
    spinner.succeed(`Prepared App Store Connect for ${chalk_1.default.bold(name)} ${chalk_1.default.dim(bundleIdentifier)}`);
    return app;
}
exports.ensureAppExistsAsync = ensureAppExistsAsync;
