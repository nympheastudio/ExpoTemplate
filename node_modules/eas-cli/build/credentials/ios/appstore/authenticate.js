"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticateAsync = exports.getRequestContext = exports.assertUserAuthCtx = exports.isUserAuthCtx = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const getenv_1 = require("getenv");
const authenticateTypes_1 = require("./authenticateTypes");
const resolveCredentials_1 = require("./resolveCredentials");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const prompts_1 = require("../../../prompts");
const APPLE_IN_HOUSE_TEAM_TYPE = 'in-house';
function isUserAuthCtx(authCtx) {
    return !!authCtx && typeof authCtx.appleId === 'string';
}
exports.isUserAuthCtx = isUserAuthCtx;
function assertUserAuthCtx(authCtx) {
    if (isUserAuthCtx(authCtx)) {
        return authCtx;
    }
    throw new Error('Expected user authentication context (login/password).');
}
exports.assertUserAuthCtx = assertUserAuthCtx;
function getRequestContext(authCtx) {
    (0, assert_1.default)(authCtx.authState?.context, 'Apple request context must be defined');
    return authCtx.authState.context;
}
exports.getRequestContext = getRequestContext;
async function loginAsync(userCredentials = {}, options) {
    // First try login with cookies JSON
    if (userCredentials.cookies) {
        const session = await apple_utils_1.Auth.loginWithCookiesAsync(userCredentials);
        // If the session isn't valid, continue to the other authentication methods.
        // Use `loginWithCookiesAsync` for a less resilient flow.
        if (session) {
            return session;
        }
    }
    // Resolve the user credentials, optimizing for password-less login.
    const { username, password } = await (0, resolveCredentials_1.resolveUserCredentialsAsync)(userCredentials);
    (0, assert_1.default)(username);
    // Clear data
    apple_utils_1.Auth.resetInMemoryData();
    try {
        // Attempt to rehydrate the session.
        const restoredSession = await apple_utils_1.Auth.tryRestoringAuthStateFromUserCredentialsAsync({
            username,
            providerId: userCredentials.providerId,
            teamId: userCredentials.teamId,
        }, options);
        if (restoredSession) {
            // Completed authentication!
            return { password, ...restoredSession };
        }
        return await loginWithUserCredentialsAsync({
            username,
            password,
            providerId: userCredentials.providerId,
            teamId: userCredentials.teamId,
        });
    }
    catch (error) {
        if (error instanceof apple_utils_1.InvalidUserCredentialsError) {
            log_1.default.error(error.message);
            // Remove the invalid password so it isn't automatically used...
            await (0, resolveCredentials_1.deletePasswordAsync)({ username });
            if (await (0, prompts_1.toggleConfirmAsync)({ message: 'Would you like to try again?' })) {
                // Don't pass credentials back or the method will throw
                return loginAsync({
                    teamId: userCredentials.teamId,
                    providerId: userCredentials.providerId,
                }, options);
            }
            else {
                throw new Error('ABORTED');
            }
        }
        throw error;
    }
}
async function loginWithUserCredentialsAsync({ username, password, teamId, providerId, }) {
    // Start a new login flow
    const newSession = await apple_utils_1.Auth.loginWithUserCredentialsAsync({
        username,
        // If the session couldn't be restored, then prompt for the password (also check if it's stored in the keychain).
        password: password || (await (0, resolveCredentials_1.promptPasswordAsync)({ username })),
        providerId,
        teamId,
    });
    // User cancelled or something.
    (0, assert_1.default)(newSession, 'An unexpected error occurred while completing authentication');
    // Success!
    return newSession;
}
async function authenticateAsync(options = {}) {
    if (options.mode === authenticateTypes_1.AuthenticationMode.API_KEY) {
        return await authenticateWithApiKeyAsync(options);
    }
    else {
        return await authenticateAsUserAsync(options);
    }
}
exports.authenticateAsync = authenticateAsync;
async function authenticateWithApiKeyAsync(options = {}) {
    // Resolve the user credentials, optimizing for password-less login.
    const ascApiKey = await (0, resolveCredentials_1.resolveAscApiKeyAsync)(options.ascApiKey);
    const team = await (0, resolveCredentials_1.resolveAppleTeamAsync)(options);
    const jwtDurationSeconds = 1200; // 20 minutes
    return {
        team,
        authState: {
            context: {
                token: new apple_utils_1.Token({
                    key: ascApiKey.keyP8,
                    issuerId: ascApiKey.issuerId,
                    keyId: ascApiKey.keyId,
                    duration: jwtDurationSeconds,
                }),
            },
        },
        ascApiKey,
    };
}
async function authenticateAsUserAsync(options = {}) {
    // help keep apple login visually apart from the other operations.
    log_1.default.addNewLineIfNone();
    try {
        const authState = await loginAsync({
            cookies: options.cookies,
            teamId: options.teamId ?? process.env.EXPO_APPLE_TEAM_ID,
            providerId: process.env.EXPO_APPLE_PROVIDER_ID
                ? (0, getenv_1.int)(process.env.EXPO_APPLE_PROVIDER_ID)
                : undefined,
        }, {
            // TODO: Provide a way to disable this for users who want to mix and match teams / providers.
            autoResolveProvider: true,
        });
        // Currently, this is resolved once, inside the apple-utils package.
        const teamId = authState.context.teamId;
        // Get all of the teams to resolve the rest of the user data.
        // TODO: optimize this step.
        const teams = await apple_utils_1.Teams.getTeamsAsync();
        const team = teams.find(team => team.teamId === teamId);
        (0, assert_1.default)(team, `Your account is not associated with Apple Team with ID: ${teamId}`);
        // Get the JSON cookies in the custom YAML format used by Fastlane
        const fastlaneSession = apple_utils_1.Session.getSessionAsYAML();
        return {
            appleId: authState.username,
            appleIdPassword: authState.password,
            team: formatTeam(team),
            // Can be used to restore the auth state using apple-utils.
            authState,
            // Defined for legacy usage in Turtle V1 or any other places where Fastlane is used in the servers.
            fastlaneSession,
        };
    }
    catch (error) {
        if (error.message === 'ABORTED') {
            process.exit(1);
        }
        log_1.default.log(chalk_1.default.red('Authentication with Apple Developer Portal failed!'));
        throw error;
    }
}
function formatTeam({ teamId, name, type }) {
    return {
        id: teamId,
        name: `${name} (${type})`,
        inHouse: type.toLowerCase() === APPLE_IN_HOUSE_TEAM_TYPE,
    };
}
