"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ArchiveSource_1 = require("./ArchiveSource");
const AnalyticsManager_1 = require("../analytics/AnalyticsManager");
const common_1 = require("../analytics/common");
const generated_1 = require("../graphql/generated");
const AppPlatform_1 = require("../graphql/types/AppPlatform");
const log_1 = tslib_1.__importDefault(require("../log"));
const ora_1 = require("../ora");
const platform_1 = require("../platform");
class BaseSubmitter {
    constructor(ctx, options, sourceOptionResolver, sourceOptionAnalytics) {
        this.ctx = ctx;
        this.options = options;
        this.sourceOptionResolver = sourceOptionResolver;
        this.sourceOptionAnalytics = sourceOptionAnalytics;
    }
    async getSourceOptionsAsync() {
        const resolvedSourceOptions = {};
        // Do not perform this in parallel as some of these require user interaction
        for (const key in this.sourceOptionResolver) {
            const sourceOptionKey = key;
            const sourceOptionAnalytics = this.sourceOptionAnalytics[sourceOptionKey];
            const sourceOption = await (0, common_1.withAnalyticsAsync)(this.ctx.analytics, async () => await this.sourceOptionResolver[sourceOptionKey](), {
                attemptEvent: sourceOptionAnalytics.attemptEvent,
                successEvent: sourceOptionAnalytics.successEvent,
                failureEvent: sourceOptionAnalytics.failureEvent,
                properties: this.ctx.analyticsEventProperties,
            });
            resolvedSourceOptions[sourceOptionKey] = sourceOption;
        }
        return resolvedSourceOptions;
    }
    async submitAsync() {
        const resolvedSourceOptions = await this.getSourceOptionsAsync();
        const input = await this.createSubmissionInputAsync(resolvedSourceOptions);
        return await this.createSubmissionWithAnalyticsAsync(input);
    }
    formatArchive(archive) {
        switch (archive.sourceType) {
            case ArchiveSource_1.ArchiveSourceType.url: {
                return { archiveSource: { type: generated_1.SubmissionArchiveSourceType.Url, url: archive.url } };
            }
            case ArchiveSource_1.ArchiveSourceType.gcs: {
                return {
                    archiveSource: {
                        type: generated_1.SubmissionArchiveSourceType.GcsSubmitArchive,
                        bucketKey: archive.bucketKey,
                    },
                };
            }
            case ArchiveSource_1.ArchiveSourceType.build: {
                return { buildId: archive.build.id };
            }
        }
    }
    async createSubmissionAsync(submissionInput) {
        log_1.default.addNewLineIfNone();
        const platformDisplayName = platform_1.appPlatformDisplayNames[(0, AppPlatform_1.toAppPlatform)(this.ctx.platform)];
        const scheduleSpinner = (0, ora_1.ora)(`Scheduling ${platformDisplayName} submission`).start();
        try {
            const submission = this.createPlatformSubmissionAsync(submissionInput);
            scheduleSpinner.succeed(`Scheduled ${platformDisplayName} submission`);
            return submission;
        }
        catch (err) {
            scheduleSpinner.fail(`Failed to schedule ${platformDisplayName} submission`);
            throw err;
        }
    }
    async createSubmissionWithAnalyticsAsync(submissionInput) {
        return await (0, common_1.withAnalyticsAsync)(this.ctx.analytics, async () => this.createSubmissionAsync(submissionInput), {
            attemptEvent: AnalyticsManager_1.SubmissionEvent.SUBMIT_REQUEST_ATTEMPT,
            successEvent: AnalyticsManager_1.SubmissionEvent.SUBMIT_REQUEST_SUCCESS,
            failureEvent: AnalyticsManager_1.SubmissionEvent.SUBMIT_REQUEST_FAIL,
            properties: this.ctx.analyticsEventProperties,
        });
    }
}
exports.default = BaseSubmitter;
