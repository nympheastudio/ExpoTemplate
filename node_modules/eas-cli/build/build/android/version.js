"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRemoteVersionCodeAsync = exports.updateNativeVersionsAsync = exports.maybeResolveVersionsAsync = exports.bumpVersionInAppJsonAsync = exports.bumpVersionAsync = exports.BumpStrategy = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const generated_1 = require("../../graphql/generated");
const AppVersionMutation_1 = require("../../graphql/mutations/AppVersionMutation");
const AppVersionQuery_1 = require("../../graphql/queries/AppVersionQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const gradleUtils_1 = require("../../project/android/gradleUtils");
const versions_1 = require("../../project/android/versions");
const workflow_1 = require("../../project/workflow");
const appJson_1 = require("../utils/appJson");
const version_1 = require("../utils/version");
var BumpStrategy;
(function (BumpStrategy) {
    BumpStrategy[BumpStrategy["APP_VERSION"] = 0] = "APP_VERSION";
    BumpStrategy[BumpStrategy["VERSION_CODE"] = 1] = "VERSION_CODE";
    BumpStrategy[BumpStrategy["NOOP"] = 2] = "NOOP";
})(BumpStrategy || (exports.BumpStrategy = BumpStrategy = {}));
async function bumpVersionAsync({ bumpStrategy, projectDir, exp, }) {
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    (0, version_1.ensureStaticConfigExists)(projectDir);
    const buildGradle = await (0, gradleUtils_1.getAppBuildGradleAsync)(projectDir);
    const isMultiFlavor = buildGradle.android?.productFlavors || buildGradle.android?.flavorDimensions;
    if (isMultiFlavor) {
        throw new Error('Automatic version bumping is not supported for multi-flavor Android projects.');
    }
    await bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp });
    log_1.default.log('Updated versions in app.json');
    await updateNativeVersionsAsync({
        projectDir,
        version: exp.version,
        versionCode: exp.android?.versionCode,
    });
    log_1.default.log('Synchronized versions with build gradle');
}
exports.bumpVersionAsync = bumpVersionAsync;
async function bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp, }) {
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    (0, version_1.ensureStaticConfigExists)(projectDir);
    log_1.default.addNewLineIfNone();
    if (bumpStrategy === BumpStrategy.APP_VERSION) {
        const appVersion = config_plugins_1.AndroidConfig.Version.getVersionName(exp) ?? '1.0.0';
        await (0, version_1.bumpAppVersionAsync)({ appVersion, projectDir, exp });
    }
    else {
        const versionCode = config_plugins_1.AndroidConfig.Version.getVersionCode(exp);
        const bumpedVersionCode = (0, versions_1.getNextVersionCode)(versionCode);
        log_1.default.log(`Bumping ${chalk_1.default.bold('expo.android.versionCode')} from ${chalk_1.default.bold(versionCode)} to ${chalk_1.default.bold(bumpedVersionCode)}`);
        await (0, appJson_1.updateAppJsonConfigAsync)({ projectDir, exp }, config => {
            config.android = { ...config.android, versionCode: bumpedVersionCode };
        });
    }
}
exports.bumpVersionInAppJsonAsync = bumpVersionInAppJsonAsync;
async function maybeResolveVersionsAsync(projectDir, exp, buildProfile, vcsClient) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.ANDROID, vcsClient);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        const buildGradle = await (0, gradleUtils_1.getAppBuildGradleAsync)(projectDir);
        try {
            const parsedGradleCommand = buildProfile.gradleCommand
                ? (0, gradleUtils_1.parseGradleCommand)(buildProfile.gradleCommand, buildGradle)
                : undefined;
            return {
                appVersion: (0, gradleUtils_1.resolveConfigValue)(buildGradle, 'versionName', parsedGradleCommand?.flavor) ?? '1.0.0',
                appBuildVersion: (0, gradleUtils_1.resolveConfigValue)(buildGradle, 'versionCode', parsedGradleCommand?.flavor) ?? '1',
            };
        }
        catch {
            return {};
        }
    }
    else {
        return {
            appBuildVersion: String(config_plugins_1.AndroidConfig.Version.getVersionCode(exp)),
            appVersion: exp.version,
        };
    }
}
exports.maybeResolveVersionsAsync = maybeResolveVersionsAsync;
async function updateNativeVersionsAsync({ projectDir, version, versionCode, }) {
    const buildGradle = await readBuildGradleAsync(projectDir);
    if (!buildGradle) {
        throw new Error('This project is missing a build.gradle file.');
    }
    let updatedBuildGradle = buildGradle;
    if (version !== undefined) {
        updatedBuildGradle = updatedBuildGradle.replace(new RegExp(`versionName ".*"`), `versionName "${version}"`);
    }
    if (versionCode !== undefined) {
        updatedBuildGradle = updatedBuildGradle.replace(new RegExp(`versionCode.*`), `versionCode ${versionCode}`);
    }
    await writeBuildGradleAsync({ projectDir, buildGradle: updatedBuildGradle });
}
exports.updateNativeVersionsAsync = updateNativeVersionsAsync;
async function readBuildGradleAsync(projectDir) {
    const buildGradlePath = config_plugins_1.AndroidConfig.Paths.getAppBuildGradleFilePath(projectDir);
    if (!(await fs_extra_1.default.pathExists(buildGradlePath))) {
        return undefined;
    }
    return await fs_extra_1.default.readFile(buildGradlePath, 'utf8');
}
async function writeBuildGradleAsync({ projectDir, buildGradle, }) {
    const buildGradlePath = config_plugins_1.AndroidConfig.Paths.getAppBuildGradleFilePath(projectDir);
    await fs_extra_1.default.writeFile(buildGradlePath, buildGradle);
}
/**
 * Returns buildNumber that will be used for the next build. If current build profile
 * has an 'autoIncrement' option set, it increments the version on server.
 */
async function resolveRemoteVersionCodeAsync(graphqlClient, { projectDir, projectId, exp, applicationId, buildProfile, vcsClient, }) {
    const remoteVersions = await AppVersionQuery_1.AppVersionQuery.latestVersionAsync(graphqlClient, projectId, generated_1.AppPlatform.Android, applicationId);
    const localVersions = await maybeResolveVersionsAsync(projectDir, exp, buildProfile, vcsClient);
    let currentBuildVersion;
    if (remoteVersions?.buildVersion) {
        currentBuildVersion = remoteVersions.buildVersion;
    }
    else {
        if (localVersions.appBuildVersion) {
            log_1.default.warn('No remote versions are configured for this project, versionCode will be initialized based on the value from the local project.');
            currentBuildVersion = localVersions.appBuildVersion;
        }
        else {
            log_1.default.error(`Remote versions are not configured and EAS CLI was not able to read the current version from your project. Use "eas build:version:set" to initialize remote versions.`);
            throw new Error('Remote versions are not configured.');
        }
    }
    if (!buildProfile.autoIncrement && remoteVersions?.buildVersion) {
        return currentBuildVersion;
    }
    else if (!buildProfile.autoIncrement && !remoteVersions?.buildVersion) {
        const spinner = (0, ora_1.ora)(`Initializing versionCode with ${chalk_1.default.bold(currentBuildVersion)}.`).start();
        try {
            await AppVersionMutation_1.AppVersionMutation.createAppVersionAsync(graphqlClient, {
                appId: projectId,
                platform: generated_1.AppPlatform.Android,
                applicationIdentifier: applicationId,
                storeVersion: localVersions.appVersion ?? exp.version ?? '1.0.0',
                buildVersion: currentBuildVersion,
                runtimeVersion: (await config_plugins_1.Updates.getRuntimeVersionNullableAsync(projectDir, exp, eas_build_job_1.Platform.ANDROID)) ??
                    undefined,
            });
            spinner.succeed(`Initialized versionCode with ${chalk_1.default.bold(currentBuildVersion)}.`);
        }
        catch (err) {
            spinner.fail(`Failed to initialize versionCode with ${chalk_1.default.bold(currentBuildVersion)}.`);
            throw err;
        }
        return currentBuildVersion;
    }
    else {
        const nextBuildVersion = (0, versions_1.getNextVersionCode)(currentBuildVersion);
        const spinner = (0, ora_1.ora)(`Incrementing versionCode from ${chalk_1.default.bold(currentBuildVersion)} to ${chalk_1.default.bold(nextBuildVersion)}.`).start();
        try {
            await AppVersionMutation_1.AppVersionMutation.createAppVersionAsync(graphqlClient, {
                appId: projectId,
                platform: generated_1.AppPlatform.Android,
                applicationIdentifier: applicationId,
                storeVersion: localVersions.appVersion ?? exp.version ?? '1.0.0',
                buildVersion: String(nextBuildVersion),
                runtimeVersion: (await config_plugins_1.Updates.getRuntimeVersionNullableAsync(projectDir, exp, eas_build_job_1.Platform.ANDROID)) ??
                    undefined,
            });
            spinner.succeed(`Incremented versionCode from ${chalk_1.default.bold(currentBuildVersion)} to ${chalk_1.default.bold(nextBuildVersion)}.`);
        }
        catch (err) {
            spinner.fail(`Failed to increment versionCode from ${chalk_1.default.bold(currentBuildVersion)} to ${chalk_1.default.bold(nextBuildVersion)}.`);
            throw err;
        }
        return String(nextBuildVersion);
    }
}
exports.resolveRemoteVersionCodeAsync = resolveRemoteVersionCodeAsync;
