"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.truncateGitCommitMessage = exports.getReactNativeVersionAsync = exports.collectMetadataAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const resolve_from_1 = tslib_1.__importDefault(require("resolve-from"));
const version_1 = require("./android/version");
const version_2 = require("./ios/version");
const local_1 = require("./local");
const types_1 = require("./types");
const log_1 = tslib_1.__importDefault(require("../log"));
const projectUtils_1 = require("../project/projectUtils");
const resolveRuntimeVersionAsync_1 = require("../project/resolveRuntimeVersionAsync");
const UpdatesModule_1 = require("../update/android/UpdatesModule");
const UpdatesModule_2 = require("../update/ios/UpdatesModule");
const easCli_1 = require("../utils/easCli");
async function collectMetadataAsync(ctx) {
    const channelObject = await resolveChannelAsync(ctx);
    const distribution = ctx.buildProfile.distribution ?? types_1.BuildDistributionType.STORE;
    const metadata = {
        trackingContext: ctx.analyticsEventProperties,
        ...(await maybeResolveVersionsAsync(ctx)),
        cliVersion: easCli_1.easCliVersion,
        workflow: ctx.workflow,
        credentialsSource: ctx.buildProfile.credentialsSource,
        sdkVersion: ctx.exp.sdkVersion,
        runtimeVersion: (await (0, resolveRuntimeVersionAsync_1.resolveRuntimeVersionAsync)({
            exp: ctx.exp,
            platform: ctx.platform,
            workflow: ctx.workflow,
            projectDir: ctx.projectDir,
            env: ctx.buildProfile.env,
            cwd: ctx.projectDir,
        })) ?? undefined,
        reactNativeVersion: await getReactNativeVersionAsync(ctx.projectDir),
        ...channelObject,
        distribution,
        appName: ctx.exp.name,
        appIdentifier: resolveAppIdentifier(ctx),
        buildProfile: ctx.buildProfileName,
        gitCommitHash: await ctx.vcsClient.getCommitHashAsync(),
        gitCommitMessage: truncateGitCommitMessage((await ctx.vcsClient.getLastCommitMessageAsync()) ?? undefined),
        isGitWorkingTreeDirty: ctx.localBuildOptions.localBuildMode === local_1.LocalBuildMode.INTERNAL
            ? false
            : await ctx.vcsClient.hasUncommittedChangesAsync(),
        username: (0, projectUtils_1.getUsername)(ctx.exp, ctx.user),
        message: ctx.message,
        ...(ctx.platform === eas_build_job_1.Platform.IOS && {
            iosEnterpriseProvisioning: resolveIosEnterpriseProvisioning(ctx),
        }),
        runWithNoWaitFlag: ctx.noWait,
        runFromCI: ctx.runFromCI,
        customWorkflowName: ctx.customBuildConfigMetadata?.workflowName,
        developmentClient: ctx.developmentClient,
        requiredPackageManager: ctx.requiredPackageManager ?? undefined,
        selectedImage: ctx.buildProfile.image,
        customNodeVersion: ctx.buildProfile.node,
        simulator: 'simulator' in ctx.buildProfile && ctx.buildProfile.simulator,
    };
    return (0, eas_build_job_1.sanitizeMetadata)(metadata);
}
exports.collectMetadataAsync = collectMetadataAsync;
async function maybeResolveVersionsAsync(ctx) {
    if (ctx.platform === eas_build_job_1.Platform.IOS) {
        const iosContext = ctx;
        const resolvedVersion = await (0, version_2.maybeResolveVersionsAsync)(ctx.projectDir, ctx.exp, iosContext.ios.targets, ctx.vcsClient);
        if (iosContext.ios.buildNumberOverride) {
            return {
                ...resolvedVersion,
                appBuildVersion: iosContext.ios.buildNumberOverride,
            };
        }
        return resolvedVersion;
    }
    else if (ctx.platform === eas_build_job_1.Platform.ANDROID) {
        const androidCtx = ctx;
        const resolvedVersion = await (0, version_1.maybeResolveVersionsAsync)(ctx.projectDir, ctx.exp, androidCtx.buildProfile, ctx.vcsClient);
        if (androidCtx.android.versionCodeOverride) {
            return {
                ...resolvedVersion,
                appBuildVersion: androidCtx.android.versionCodeOverride,
            };
        }
        return resolvedVersion;
    }
    else {
        throw new Error(`Unsupported platform ${ctx.platform}`);
    }
}
function resolveAppIdentifier(ctx) {
    if (ctx.platform === eas_build_job_1.Platform.IOS) {
        return ctx.ios.bundleIdentifier;
    }
    else {
        return ctx.android.applicationId;
    }
}
async function resolveChannelAsync(ctx) {
    if (!(0, projectUtils_1.isExpoUpdatesInstalled)(ctx.projectDir)) {
        return null;
    }
    if (ctx.buildProfile.channel) {
        return { channel: ctx.buildProfile.channel };
    }
    const channel = await getNativeChannelAsync(ctx);
    if (channel) {
        return { channel };
    }
    return null;
}
async function getNativeChannelAsync(ctx) {
    switch (ctx.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            return (await (0, UpdatesModule_1.readChannelSafelyAsync)(ctx.projectDir)) ?? undefined;
        }
        case eas_build_job_1.Platform.IOS: {
            return (await (0, UpdatesModule_2.readChannelSafelyAsync)(ctx.projectDir)) ?? undefined;
        }
    }
    return undefined;
}
async function getReactNativeVersionAsync(projectDir) {
    try {
        const reactNativePackageJsonPath = (0, resolve_from_1.default)(projectDir, 'react-native/package.json');
        return (await fs_extra_1.default.readJson(reactNativePackageJsonPath)).version;
    }
    catch (err) {
        log_1.default.debug('Failed to resolve react-native version:');
        log_1.default.debug(err);
        return undefined;
    }
}
exports.getReactNativeVersionAsync = getReactNativeVersionAsync;
function resolveIosEnterpriseProvisioning(ctx) {
    return ctx.buildProfile.enterpriseProvisioning;
}
function truncateGitCommitMessage(msg, maxLength = 4096) {
    if (msg === undefined) {
        return undefined;
    }
    return msg.length > maxLength ? `${msg.substring(0, maxLength - 3)}...` : msg;
}
exports.truncateGitCommitMessage = truncateGitCommitMessage;
