"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reviewAndCommitChangesAsync = exports.makeProjectTarballAsync = exports.makeProjectMetadataFileAsync = exports.commitPromptAsync = exports.ensureRepoIsCleanAsync = exports.maybeBailOnRepoStatusAsync = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const tar_1 = tslib_1.__importDefault(require("tar"));
const uuid_1 = require("uuid");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const prompts_1 = require("../../prompts");
const files_1 = require("../../utils/files");
const paths_1 = require("../../utils/paths");
const timer_1 = require("../../utils/timer");
async function maybeBailOnRepoStatusAsync(vcsClient, nonInteractive) {
    if (!(await vcsClient.isCommitRequiredAsync())) {
        return;
    }
    log_1.default.addNewLineIfNone();
    log_1.default.warn(`${chalk_1.default.bold('Warning!')} Your repository working tree is dirty.`);
    log_1.default.log(`It's recommended to ${chalk_1.default.bold('commit all your changes before proceeding')}, so you can revert the changes made by this command if necessary.`);
    const answer = await (0, prompts_1.confirmAsync)({
        message: `Would you like to proceed?`,
    });
    if (!answer) {
        if (nonInteractive) {
            log_1.default.log('The following files need to be committed:');
            await vcsClient.showChangedFilesAsync();
        }
        throw new Error('Commit all changes. Aborting...');
    }
}
exports.maybeBailOnRepoStatusAsync = maybeBailOnRepoStatusAsync;
async function ensureRepoIsCleanAsync(vcsClient, nonInteractive = false) {
    if (!(await vcsClient.isCommitRequiredAsync())) {
        return;
    }
    log_1.default.addNewLineIfNone();
    log_1.default.warn(`${chalk_1.default.bold('Warning!')} Your repository working tree is dirty.`);
    log_1.default.log(`This operation needs to be run on a clean working tree. ${chalk_1.default.bold('Commit all your changes before proceeding')}.`);
    if (nonInteractive) {
        log_1.default.log('The following files need to be committed:');
        await vcsClient.showChangedFilesAsync();
        throw new Error('Commit all changes. Aborting...');
    }
    const answer = await (0, prompts_1.confirmAsync)({
        message: `Commit changes to git?`,
    });
    if (answer) {
        await commitPromptAsync(vcsClient, { commitAllFiles: true });
    }
    else {
        throw new Error('Commit all changes. Aborting...');
    }
}
exports.ensureRepoIsCleanAsync = ensureRepoIsCleanAsync;
async function commitPromptAsync(vcsClient, { initialCommitMessage, commitAllFiles, } = {}) {
    const { message } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'message',
        message: 'Commit message:',
        initial: initialCommitMessage,
        validate: (input) => input !== '',
    });
    await vcsClient.commitAsync({
        commitAllFiles,
        commitMessage: message,
        nonInteractive: false,
    });
}
exports.commitPromptAsync = commitPromptAsync;
async function makeProjectMetadataFileAsync(archivePath) {
    const spinner = (0, ora_1.ora)('Creating project metadata file');
    const timerLabel = 'makeProjectMetadataFileAsync';
    const timer = setTimeout(() => {
        spinner.start();
    }, log_1.default.isDebug ? 1 : 1000);
    (0, timer_1.startTimer)(timerLabel);
    const metadataLocation = path_1.default.join((0, paths_1.getTmpDirectory)(), `${(0, uuid_1.v4)()}-eas-build-metadata.json`);
    const archiveContent = [];
    try {
        await tar_1.default.list({
            file: archivePath,
            onentry: (entry) => {
                if (entry.type === 'File' && !entry.path.includes('.git/')) {
                    archiveContent.push(entry.path);
                }
            },
        });
        await fs_extra_1.default.writeJSON(metadataLocation, {
            archiveContent,
        });
    }
    catch (e) {
        clearTimeout(timer);
        if (spinner.isSpinning) {
            spinner.fail();
        }
        throw e;
    }
    clearTimeout(timer);
    const duration = (0, timer_1.endTimer)(timerLabel);
    const prettyTime = (0, timer_1.formatMilliseconds)(duration);
    spinner.succeed(`Created project metadata file ${chalk_1.default.dim(prettyTime)}`);
    return { path: metadataLocation, size: await fs_extra_1.default.stat(metadataLocation).then(stat => stat.size) };
}
exports.makeProjectMetadataFileAsync = makeProjectMetadataFileAsync;
async function makeProjectTarballAsync(vcsClient) {
    const spinner = (0, ora_1.ora)('Compressing project files');
    await fs_extra_1.default.mkdirp((0, paths_1.getTmpDirectory)());
    const shallowClonePath = path_1.default.join((0, paths_1.getTmpDirectory)(), `${(0, uuid_1.v4)()}-shallow-clone`);
    const tarPath = path_1.default.join((0, paths_1.getTmpDirectory)(), `${(0, uuid_1.v4)()}.tar.gz`);
    // If the compression takes longer then a second, show the spinner.
    // This can happen when the user has a lot of resources or doesn't ignore their CocoaPods.
    // A basic project on a Mac can compress in roughly ~40ms.
    // A fairly complex project without CocoaPods ignored can take up to 30s.
    const timer = setTimeout(() => {
        spinner.start();
    }, log_1.default.isDebug ? 1 : 1000);
    // TODO: Possibly warn after more time about unoptimized assets.
    const compressTimerLabel = 'makeProjectTarballAsync';
    (0, timer_1.startTimer)(compressTimerLabel);
    try {
        await vcsClient.makeShallowCopyAsync(shallowClonePath);
        await tar_1.default.create({ cwd: shallowClonePath, file: tarPath, prefix: 'project', gzip: true }, [
            '.',
        ]);
    }
    catch (err) {
        clearTimeout(timer);
        if (spinner.isSpinning) {
            spinner.fail();
        }
        throw err;
    }
    finally {
        await fs_extra_1.default.remove(shallowClonePath);
    }
    clearTimeout(timer);
    const { size } = await fs_extra_1.default.stat(tarPath);
    const duration = (0, timer_1.endTimer)(compressTimerLabel);
    if (spinner.isSpinning) {
        const prettyTime = (0, timer_1.formatMilliseconds)(duration);
        spinner.succeed(`Compressed project files ${chalk_1.default.dim(`${prettyTime} (${(0, files_1.formatBytes)(size)})`)}`);
    }
    return { size, path: tarPath };
}
exports.makeProjectTarballAsync = makeProjectTarballAsync;
var ShouldCommitChanges;
(function (ShouldCommitChanges) {
    ShouldCommitChanges[ShouldCommitChanges["Yes"] = 0] = "Yes";
    ShouldCommitChanges[ShouldCommitChanges["ShowDiffFirst"] = 1] = "ShowDiffFirst";
    ShouldCommitChanges[ShouldCommitChanges["Abort"] = 2] = "Abort";
})(ShouldCommitChanges || (ShouldCommitChanges = {}));
async function reviewAndCommitChangesAsync(vcsClient, initialCommitMessage, { nonInteractive, askedFirstTime = true }) {
    if (process.env.EAS_BUILD_AUTOCOMMIT) {
        await vcsClient.commitAsync({
            commitMessage: initialCommitMessage,
            commitAllFiles: false,
            nonInteractive,
        });
        log_1.default.withTick('Committed changes.');
        return;
    }
    if (nonInteractive) {
        throw new Error('Cannot commit changes when --non-interactive is specified. Run the command in interactive mode or set EAS_BUILD_AUTOCOMMIT=1 in your environment.');
    }
    const { selected } = await (0, prompts_1.promptAsync)({
        type: 'select',
        name: 'selected',
        message: 'Can we commit these changes to git for you?',
        choices: [
            { title: 'Yes', value: ShouldCommitChanges.Yes },
            ...(askedFirstTime
                ? [{ title: 'Show the diff and ask me again', value: ShouldCommitChanges.ShowDiffFirst }]
                : []),
            {
                title: 'Abort build process',
                value: ShouldCommitChanges.Abort,
            },
        ],
    });
    if (selected === ShouldCommitChanges.Abort) {
        throw new Error("Aborting, run the command again once you're ready. Make sure to commit any changes you've made.");
    }
    else if (selected === ShouldCommitChanges.Yes) {
        await commitPromptAsync(vcsClient, { initialCommitMessage });
        log_1.default.withTick('Committed changes.');
    }
    else if (selected === ShouldCommitChanges.ShowDiffFirst) {
        await vcsClient.showDiffAsync();
        await reviewAndCommitChangesAsync(vcsClient, initialCommitMessage, {
            nonInteractive,
            askedFirstTime: false,
        });
    }
}
exports.reviewAndCommitChangesAsync = reviewAndCommitChangesAsync;
