"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRemoteBuildNumberAsync = exports.evaluateTemplateString = exports.updateNativeVersionsAsync = exports.getInfoPlistPath = exports.maybeResolveVersionsAsync = exports.readBuildNumberAsync = exports.readShortVersionAsync = exports.bumpVersionInAppJsonAsync = exports.bumpVersionAsync = exports.BumpStrategy = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const path_1 = tslib_1.__importDefault(require("path"));
const generated_1 = require("../../graphql/generated");
const AppVersionMutation_1 = require("../../graphql/mutations/AppVersionMutation");
const AppVersionQuery_1 = require("../../graphql/queries/AppVersionQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const target_1 = require("../../project/ios/target");
const versions_1 = require("../../project/ios/versions");
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const uniqBy_1 = tslib_1.__importDefault(require("../../utils/expodash/uniqBy"));
const plist_1 = require("../../utils/plist");
const appJson_1 = require("../utils/appJson");
const version_1 = require("../utils/version");
const SHORT_VERSION_REGEX = /^\d+.\d+.\d+$/;
var BumpStrategy;
(function (BumpStrategy) {
    BumpStrategy[BumpStrategy["APP_VERSION"] = 0] = "APP_VERSION";
    BumpStrategy[BumpStrategy["BUILD_NUMBER"] = 1] = "BUILD_NUMBER";
    BumpStrategy[BumpStrategy["NOOP"] = 2] = "NOOP";
})(BumpStrategy || (exports.BumpStrategy = BumpStrategy = {}));
async function bumpVersionAsync({ bumpStrategy, projectDir, exp, targets, }) {
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    (0, version_1.ensureStaticConfigExists)(projectDir);
    await bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp });
    log_1.default.log('Updated versions in app.json');
    await updateNativeVersionsAsync({
        projectDir,
        version: exp.version,
        buildNumber: exp.ios?.buildNumber,
        targets,
    });
    log_1.default.log('Synchronized versions with Info.plist');
}
exports.bumpVersionAsync = bumpVersionAsync;
async function bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp, }) {
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    (0, version_1.ensureStaticConfigExists)(projectDir);
    log_1.default.addNewLineIfNone();
    if (bumpStrategy === BumpStrategy.APP_VERSION) {
        const appVersion = config_plugins_1.IOSConfig.Version.getVersion(exp);
        await (0, version_1.bumpAppVersionAsync)({ appVersion, projectDir, exp });
    }
    else {
        const buildNumber = config_plugins_1.IOSConfig.Version.getBuildNumber(exp);
        if ((0, versions_1.isValidBuildNumber)(buildNumber)) {
            const bumpedBuildNumber = (0, versions_1.getNextBuildNumber)(buildNumber);
            log_1.default.log(`Bumping ${chalk_1.default.bold('expo.ios.buildNumber')} from ${chalk_1.default.bold(buildNumber)} to ${chalk_1.default.bold(bumpedBuildNumber)}`);
            await (0, appJson_1.updateAppJsonConfigAsync)({ projectDir, exp }, config => {
                config.ios = { ...config.ios, buildNumber: String(bumpedBuildNumber) };
            });
        }
        else {
            log_1.default.log(`${chalk_1.default.bold('expo.ios.buildNumber')} = ${chalk_1.default.bold(buildNumber)} is not a number`);
            const { bumpedBuildNumber } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'bumpedBuildNumber',
                message: 'What is the next build number?',
            });
            await (0, appJson_1.updateAppJsonConfigAsync)({ projectDir, exp }, config => {
                config.ios = { ...config.ios, buildNumber: String(bumpedBuildNumber) };
            });
        }
    }
}
exports.bumpVersionInAppJsonAsync = bumpVersionInAppJsonAsync;
function validateShortVersion(shortVersion) {
    if (shortVersion && !SHORT_VERSION_REGEX.test(shortVersion)) {
        throw new Error(`CFBundleShortVersionString (version field in app.json/app.config.js) must be a period-separated list of three non-negative integers. Current value: ${shortVersion}`);
    }
}
async function readShortVersionAsync(projectDir, exp, buildSettings, vcsClient) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS, vcsClient);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        const infoPlist = await readInfoPlistAsync(projectDir, buildSettings);
        const shortVersion = infoPlist.CFBundleShortVersionString &&
            evaluateTemplateString(infoPlist.CFBundleShortVersionString, buildSettings);
        validateShortVersion(shortVersion);
        return shortVersion;
    }
    else {
        validateShortVersion(exp.version);
        return exp.version;
    }
}
exports.readShortVersionAsync = readShortVersionAsync;
async function readBuildNumberAsync(projectDir, exp, buildSettings, vcsClient) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS, vcsClient);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        const infoPlist = await readInfoPlistAsync(projectDir, buildSettings);
        return (infoPlist.CFBundleVersion && evaluateTemplateString(infoPlist.CFBundleVersion, buildSettings));
    }
    else {
        return config_plugins_1.IOSConfig.Version.getBuildNumber(exp);
    }
}
exports.readBuildNumberAsync = readBuildNumberAsync;
async function maybeResolveVersionsAsync(projectDir, exp, targets, vcsClient) {
    const applicationTarget = (0, target_1.findApplicationTarget)(targets);
    try {
        return {
            appBuildVersion: await readBuildNumberAsync(projectDir, exp, applicationTarget.buildSettings ?? {}, vcsClient),
            appVersion: await readShortVersionAsync(projectDir, exp, applicationTarget.buildSettings ?? {}, vcsClient),
        };
    }
    catch (err) {
        log_1.default.warn('Failed to read app versions.');
        log_1.default.debug(err);
        log_1.default.warn(err.message);
        log_1.default.warn('Proceeding anyway...');
        return {};
    }
}
exports.maybeResolveVersionsAsync = maybeResolveVersionsAsync;
function getInfoPlistPath(projectDir, buildSettings) {
    if (buildSettings.INFOPLIST_FILE) {
        const infoPlistFile = buildSettings.INFOPLIST_FILE.startsWith('"')
            ? buildSettings.INFOPLIST_FILE.slice(1, -1)
            : buildSettings.INFOPLIST_FILE;
        const iosDir = path_1.default.join(projectDir, 'ios');
        const plistPath = evaluateTemplateString(infoPlistFile, {
            ...buildSettings,
            SRCROOT: iosDir,
        });
        return path_1.default.isAbsolute(plistPath) ? plistPath : path_1.default.resolve(iosDir, plistPath);
    }
    else {
        return config_plugins_1.IOSConfig.Paths.getInfoPlistPath(projectDir);
    }
}
exports.getInfoPlistPath = getInfoPlistPath;
async function readInfoPlistAsync(projectDir, buildSettings) {
    const infoPlistPath = getInfoPlistPath(projectDir, buildSettings);
    return ((await (0, plist_1.readPlistAsync)(infoPlistPath)) ?? {});
}
async function updateNativeVersionsAsync({ projectDir, version, buildNumber, targets, }) {
    const project = config_plugins_1.IOSConfig.XcodeUtils.getPbxproj(projectDir);
    const iosDir = path_1.default.join(projectDir, 'ios');
    const infoPlistFiles = [];
    for (const target of targets) {
        const { targetName, buildConfiguration } = target;
        const xcBuildConfiguration = config_plugins_1.IOSConfig.Target.getXCBuildConfigurationFromPbxproj(project, {
            targetName,
            buildConfiguration,
        });
        const infoPlist = xcBuildConfiguration?.buildSettings?.INFOPLIST_FILE;
        if (infoPlist) {
            const evaluatedInfoPlistPath = trimQuotes(evaluateTemplateString(infoPlist, {
                SRCROOT: iosDir,
            }));
            const absolutePath = path_1.default.isAbsolute(evaluatedInfoPlistPath)
                ? evaluatedInfoPlistPath
                : path_1.default.join(iosDir, evaluatedInfoPlistPath);
            infoPlistFiles.push(path_1.default.normalize(absolutePath));
        }
    }
    const uniqueInfoPlistPaths = (0, uniqBy_1.default)(infoPlistFiles, i => i);
    for (const infoPlistPath of uniqueInfoPlistPaths) {
        const infoPlist = (await (0, plist_1.readPlistAsync)(infoPlistPath));
        if (buildNumber) {
            infoPlist.CFBundleVersion = buildNumber;
        }
        if (version) {
            infoPlist.CFBundleShortVersionString = version;
        }
        await (0, plist_1.writePlistAsync)(infoPlistPath, infoPlist);
    }
}
exports.updateNativeVersionsAsync = updateNativeVersionsAsync;
function trimQuotes(s) {
    return s?.startsWith('"') && s.endsWith('"') ? s.slice(1, -1) : s;
}
function evaluateTemplateString(s, buildSettings) {
    // necessary because XCBuildConfiguration['buildSettings'] is not a plain object
    const vars = { ...buildSettings };
    return s.replace(/\$\((\w+)\)/g, (match, key) => {
        if (vars.hasOwnProperty(key)) {
            const value = String(vars[key]);
            return value.startsWith('"') ? value.slice(1, -1) : value;
        }
        else {
            return match;
        }
    });
}
exports.evaluateTemplateString = evaluateTemplateString;
/**
 * Returns buildNumber that will be used for the next build. If current build profile
 * has an 'autoIncrement' option set, it increments the version on server.
 */
async function resolveRemoteBuildNumberAsync(graphqlClient, { projectDir, projectId, exp, applicationTarget, buildProfile, vcsClient, }) {
    const remoteVersions = await AppVersionQuery_1.AppVersionQuery.latestVersionAsync(graphqlClient, projectId, generated_1.AppPlatform.Ios, applicationTarget.bundleIdentifier);
    const localBuildNumber = await readBuildNumberAsync(projectDir, exp, applicationTarget.buildSettings ?? {}, vcsClient);
    const localShortVersion = await readShortVersionAsync(projectDir, exp, applicationTarget.buildSettings ?? {}, vcsClient);
    let currentBuildVersion;
    if (remoteVersions?.buildVersion) {
        currentBuildVersion = remoteVersions.buildVersion;
    }
    else {
        if (localBuildNumber) {
            log_1.default.warn('No remote versions are configured for this project, buildNumber will be initialized based on the value from the local project.');
            currentBuildVersion = localBuildNumber;
        }
        else {
            log_1.default.error(`Remote versions are not configured and EAS CLI was not able to read the current version from your project. Use "eas build:version:set" to initialize remote versions.`);
            throw new Error('Remote versions are not configured.');
        }
    }
    if (!buildProfile.autoIncrement && remoteVersions?.buildVersion) {
        return currentBuildVersion;
    }
    else if (!buildProfile.autoIncrement && !remoteVersions?.buildVersion) {
        const spinner = (0, ora_1.ora)(`Initializing buildNumber with ${chalk_1.default.bold(currentBuildVersion)}.`).start();
        try {
            await AppVersionMutation_1.AppVersionMutation.createAppVersionAsync(graphqlClient, {
                appId: projectId,
                platform: generated_1.AppPlatform.Ios,
                applicationIdentifier: applicationTarget.bundleIdentifier,
                storeVersion: localShortVersion ?? '1.0.0',
                buildVersion: currentBuildVersion,
                runtimeVersion: (await config_plugins_1.Updates.getRuntimeVersionNullableAsync(projectDir, exp, eas_build_job_1.Platform.IOS)) ??
                    undefined,
            });
            spinner.succeed(`Initialized buildNumber with ${chalk_1.default.bold(currentBuildVersion)}.`);
        }
        catch (err) {
            spinner.fail(`Failed to initialize buildNumber with ${chalk_1.default.bold(currentBuildVersion)}.`);
            throw err;
        }
        return currentBuildVersion;
    }
    else {
        const nextBuildVersion = (0, versions_1.getNextBuildNumber)(currentBuildVersion);
        const spinner = (0, ora_1.ora)(`Incrementing buildNumber from ${chalk_1.default.bold(currentBuildVersion)} to ${chalk_1.default.bold(nextBuildVersion)}.`).start();
        try {
            await AppVersionMutation_1.AppVersionMutation.createAppVersionAsync(graphqlClient, {
                appId: projectId,
                platform: generated_1.AppPlatform.Ios,
                applicationIdentifier: applicationTarget.bundleIdentifier,
                storeVersion: localShortVersion ?? '1.0.0',
                buildVersion: nextBuildVersion,
                runtimeVersion: (await config_plugins_1.Updates.getRuntimeVersionNullableAsync(projectDir, exp, eas_build_job_1.Platform.IOS)) ??
                    undefined,
            });
            spinner.succeed(`Incremented buildNumber from ${chalk_1.default.bold(currentBuildVersion)} to ${chalk_1.default.bold(nextBuildVersion)}.`);
        }
        catch (err) {
            spinner.fail(`Failed to increment buildNumber from ${chalk_1.default.bold(currentBuildVersion)} to ${chalk_1.default.bold(nextBuildVersion)}.`);
            throw err;
        }
        return nextBuildVersion;
    }
}
exports.resolveRemoteBuildNumberAsync = resolveRemoteBuildNumberAsync;
