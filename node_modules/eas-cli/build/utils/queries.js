"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.paginatedQueryWithSelectPromptAsync = exports.paginatedQueryWithConfirmPromptAsync = void 0;
const tslib_1 = require("tslib");
const uniqBy_1 = tslib_1.__importDefault(require("./expodash/uniqBy"));
const prompts_1 = require("../prompts");
const fetchMoreValue = '_fetchMore';
async function paginatedQueryWithConfirmPromptAsync(queryArgs) {
    return await paginatedQueryWithConfirmPromptInternalAsync(queryArgs, []);
}
exports.paginatedQueryWithConfirmPromptAsync = paginatedQueryWithConfirmPromptAsync;
async function paginatedQueryWithConfirmPromptInternalAsync({ limit, offset, queryToPerform, promptOptions, }, accumulator) {
    // query an extra item to determine if there are more pages left
    const paginatedItems = await queryToPerform(limit + 1, offset);
    const areMorePagesAvailable = paginatedItems.length > limit;
    // drop that extra item used for pagination from our render logic
    const currentPage = paginatedItems.slice(0, limit);
    const newAccumulator = [...accumulator, ...currentPage];
    promptOptions.renderListItems(currentPage);
    if (!areMorePagesAvailable) {
        return;
    }
    if (await (0, prompts_1.confirmAsync)({ message: promptOptions.title })) {
        return await paginatedQueryWithConfirmPromptInternalAsync({
            limit,
            offset: offset + limit,
            queryToPerform,
            promptOptions,
        }, newAccumulator);
    }
}
/**
 * Returns an array of item(s) where the id is equal to the id of the user's selected item
 * If no items are available for a user to select, this will return an empty array.
 */
async function paginatedQueryWithSelectPromptAsync(queryArgs) {
    return await paginatedQueryWithSelectPromptInternalAsync(queryArgs, []);
}
exports.paginatedQueryWithSelectPromptAsync = paginatedQueryWithSelectPromptAsync;
async function paginatedQueryWithSelectPromptInternalAsync({ limit, offset, queryToPerform, promptOptions, }, accumulator) {
    // query an extra item to determine if there are more pages left
    const paginatedItems = await queryToPerform(limit + 1, offset);
    const areMorePagesAvailable = paginatedItems.length > limit;
    // drop that extra item used for pagination from our render logic
    const currentPage = paginatedItems.slice(0, limit);
    const newAccumulator = [...accumulator, ...currentPage];
    const selectionPromptListItems = (0, uniqBy_1.default)(newAccumulator, queryItem => promptOptions.getIdentifierForQueryItem(queryItem)).map(queryItem => ({
        ...promptOptions.makePartialChoiceObject(queryItem),
        value: promptOptions.getIdentifierForQueryItem(queryItem),
    }));
    if (areMorePagesAvailable) {
        selectionPromptListItems.push({ title: 'Next page...', value: fetchMoreValue });
    }
    if (selectionPromptListItems.length === 0) {
        return;
    }
    const valueOfUserSelectedListItem = await (0, prompts_1.selectAsync)(promptOptions.title, selectionPromptListItems, {
        warningMessageForDisabledEntries: promptOptions.selectPromptWarningMessage,
    });
    if (valueOfUserSelectedListItem === fetchMoreValue) {
        return await paginatedQueryWithSelectPromptInternalAsync({
            limit,
            offset: offset + limit,
            queryToPerform,
            promptOptions,
        }, newAccumulator);
    }
    return newAccumulator.find(items => promptOptions.getIdentifierForQueryItem(items) === valueOfUserSelectedListItem);
}
