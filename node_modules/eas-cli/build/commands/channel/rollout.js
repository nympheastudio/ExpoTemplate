"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const EndRollout_1 = require("../../rollout/actions/EndRollout");
const ManageRollout_1 = require("../../rollout/actions/ManageRollout");
const NonInteractiveRollout_1 = require("../../rollout/actions/NonInteractiveRollout");
const RolloutMainMenu_1 = require("../../rollout/actions/RolloutMainMenu");
const json_1 = require("../../utils/json");
var ActionRawFlagValue;
(function (ActionRawFlagValue) {
    ActionRawFlagValue["CREATE"] = "create";
    ActionRawFlagValue["EDIT"] = "edit";
    ActionRawFlagValue["END"] = "end";
    ActionRawFlagValue["VIEW"] = "view";
})(ActionRawFlagValue || (ActionRawFlagValue = {}));
class ChannelRollout extends EasCommand_1.default {
    async runAsync() {
        const { args, flags } = await this.parse(_a);
        const argsAndFlags = this.sanitizeArgsAndFlags({ ...flags, ...args });
        const { privateProjectConfig: { exp, projectId, projectDir }, vcsClient, loggedIn: { graphqlClient }, } = await this.getContextAsync(_a, {
            nonInteractive: argsAndFlags.nonInteractive,
        });
        if (argsAndFlags.json) {
            (0, json_1.enableJsonOutput)();
        }
        const app = { projectId, exp, projectDir };
        const ctx = {
            nonInteractive: argsAndFlags.nonInteractive,
            graphqlClient,
            app,
            vcsClient,
        };
        if (argsAndFlags.nonInteractive) {
            await new NonInteractiveRollout_1.NonInteractiveRollout(argsAndFlags).runAsync(ctx);
        }
        else {
            await new RolloutMainMenu_1.RolloutMainMenu(argsAndFlags).runAsync(ctx);
        }
    }
    getAction(action) {
        switch (action) {
            case ActionRawFlagValue.CREATE:
                return RolloutMainMenu_1.MainMenuActions.CREATE_NEW;
            case ActionRawFlagValue.EDIT:
                return ManageRollout_1.ManageRolloutActions.EDIT;
            case ActionRawFlagValue.END:
                return ManageRollout_1.ManageRolloutActions.END;
            case ActionRawFlagValue.VIEW:
                return ManageRollout_1.ManageRolloutActions.VIEW;
        }
    }
    sanitizeArgsAndFlags(rawFlags) {
        const action = rawFlags.action;
        return {
            channelName: rawFlags.channel,
            percent: rawFlags.percent,
            outcome: rawFlags.outcome,
            branchNameToRollout: rawFlags.branch,
            runtimeVersion: rawFlags['runtime-version'],
            privateKeyPath: rawFlags['private-key-path'] ?? null,
            action: action ? this.getAction(action) : undefined,
            nonInteractive: rawFlags['non-interactive'],
            json: rawFlags.json,
        };
    }
}
_a = ChannelRollout;
ChannelRollout.description = 'Roll a new branch out on a channel incrementally.';
ChannelRollout.args = [
    {
        name: 'channel',
        description: 'channel on which the rollout should be done',
    },
];
ChannelRollout.flags = {
    action: core_1.Flags.enum({
        description: 'Rollout action to perform',
        options: Object.values(ActionRawFlagValue),
        required: false,
        relationships: [
            {
                type: 'all',
                flags: [
                    {
                        name: 'percent',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => {
                            return (!!flags['non-interactive'] &&
                                (flags['action'] === ActionRawFlagValue.CREATE ||
                                    flags['action'] === ActionRawFlagValue.EDIT));
                        },
                    },
                    {
                        name: 'outcome',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => !!flags['non-interactive'] && flags['action'] === ActionRawFlagValue.END,
                    },
                    {
                        name: 'branch',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => !!flags['non-interactive'] && flags['action'] === ActionRawFlagValue.CREATE,
                    },
                    {
                        name: 'runtime-version',
                        // eslint-disable-next-line async-protect/async-suffix
                        when: async (flags) => !!flags['non-interactive'] && flags['action'] === ActionRawFlagValue.CREATE,
                    },
                ],
            },
        ],
    }),
    percent: core_1.Flags.integer({
        description: 'Percent of users to send to the new branch. Use with --action=edit or --action=create',
        required: false,
    }),
    outcome: core_1.Flags.enum({
        description: 'End outcome of rollout. Use with --action=end',
        options: Object.values(EndRollout_1.EndOutcome),
        required: false,
    }),
    branch: core_1.Flags.string({
        description: 'Branch to roll out. Use with --action=create',
        required: false,
    }),
    'runtime-version': core_1.Flags.string({
        description: 'Runtime version to target. Use with --action=create',
        required: false,
    }),
    'private-key-path': core_1.Flags.string({
        description: `File containing the PEM-encoded private key corresponding to the certificate in expo-updates' configuration. Defaults to a file named "private-key.pem" in the certificate's directory.`,
        required: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
ChannelRollout.contextDefinition = {
    ..._a.ContextOptions.ProjectConfig,
    ..._a.ContextOptions.Vcs,
    ..._a.ContextOptions.LoggedIn,
};
exports.default = ChannelRollout;
