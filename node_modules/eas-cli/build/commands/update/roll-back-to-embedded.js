"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const queries_1 = require("../../branch/queries");
const url_1 = require("../../build/utils/url");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const pagination_1 = require("../../commandUtils/pagination");
const fetch_1 = tslib_1.__importDefault(require("../../fetch"));
const generated_1 = require("../../graphql/generated");
const PublishMutation_1 = require("../../graphql/mutations/PublishMutation");
const log_1 = tslib_1.__importStar(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const publish_1 = require("../../project/publish");
const workflow_1 = require("../../project/workflow");
const configure_1 = require("../../update/configure");
const utils_1 = require("../../update/utils");
const code_signing_1 = require("../../utils/code-signing");
const uniqBy_1 = tslib_1.__importDefault(require("../../utils/expodash/uniqBy"));
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
const statuspageService_1 = require("../../utils/statuspageService");
class UpdateRollBackToEmbedded extends EasCommand_1.default {
    async runAsync() {
        const { flags: rawFlags } = await this.parse(_a);
        const paginatedQueryOptions = (0, pagination_1.getPaginatedQueryOptions)(rawFlags);
        const { auto: autoFlag, platform: platformFlag, channelName: channelNameArg, updateMessage: updateMessageArg, privateKeyPath, json: jsonFlag, nonInteractive, branchName: branchNameArg, } = this.sanitizeFlags(rawFlags);
        const { getDynamicPublicProjectConfigAsync, getDynamicPrivateProjectConfigAsync, loggedIn: { graphqlClient }, vcsClient, } = await this.getContextAsync(_a, {
            nonInteractive,
        });
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const { exp: expPossiblyWithoutEasUpdateConfigured, projectId, projectDir, } = await getDynamicPublicProjectConfigAsync();
        await (0, statuspageService_1.maybeWarnAboutEasOutagesAsync)(graphqlClient, [generated_1.StatuspageServiceName.EasUpdate]);
        await (0, configure_1.ensureEASUpdateIsConfiguredAsync)({
            exp: expPossiblyWithoutEasUpdateConfigured,
            platform: (0, publish_1.getRequestedPlatform)(platformFlag),
            projectDir,
            projectId,
            vcsClient,
            env: undefined,
        });
        // check that the expo-updates package version supports roll back to embedded
        await (0, projectUtils_1.enforceRollBackToEmbeddedUpdateSupportAsync)(projectDir);
        const { exp } = await getDynamicPublicProjectConfigAsync();
        const { exp: expPrivate } = await getDynamicPrivateProjectConfigAsync();
        const codeSigningInfo = await (0, code_signing_1.getCodeSigningInfoAsync)(expPrivate, privateKeyPath);
        const branchName = await (0, publish_1.getBranchNameForCommandAsync)({
            graphqlClient,
            vcsClient,
            projectId,
            channelNameArg,
            branchNameArg,
            autoFlag,
            nonInteractive,
            paginatedQueryOptions,
        });
        const updateMessage = await (0, publish_1.getUpdateMessageForCommandAsync)(vcsClient, {
            updateMessageArg,
            autoFlag,
            nonInteractive,
            jsonFlag,
        });
        const realizedPlatforms = platformFlag === 'all' ? publish_1.defaultPublishPlatforms : [platformFlag];
        const { branchId } = await (0, queries_1.ensureBranchExistsAsync)(graphqlClient, {
            appId: projectId,
            branchName,
        });
        const gitCommitHash = await vcsClient.getCommitHashAsync();
        const isGitWorkingTreeDirty = await vcsClient.hasUncommittedChangesAsync();
        const workflows = await (0, workflow_1.resolveWorkflowPerPlatformAsync)(projectDir, vcsClient);
        const runtimeVersions = await (0, publish_1.getRuntimeVersionObjectAsync)({
            exp,
            platforms: realizedPlatforms,
            projectDir,
            workflows: {
                ...workflows,
                web: eas_build_job_1.Workflow.UNKNOWN,
            },
            env: undefined,
        });
        let newUpdates;
        const publishSpinner = (0, ora_1.ora)('Publishing...').start();
        try {
            newUpdates = await this.publishRollbacksAsync({
                graphqlClient,
                isGitWorkingTreeDirty,
                gitCommitHash,
                updateMessage,
                branchId,
                codeSigningInfo,
                runtimeVersions,
                realizedPlatforms,
            });
            publishSpinner.succeed('Published!');
        }
        catch (e) {
            publishSpinner.fail('Failed to publish updates');
            throw e;
        }
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)((0, utils_1.getUpdateJsonInfosForUpdates)(newUpdates));
        }
        else {
            if (new Set(newUpdates.map(update => update.group)).size > 1) {
                log_1.default.addNewLineIfNone();
                log_1.default.log('ðŸ‘‰ Since multiple runtime versions are defined, multiple update groups have been published.');
            }
            log_1.default.addNewLineIfNone();
            for (const runtime of (0, uniqBy_1.default)(runtimeVersions, version => version.runtimeVersion)) {
                const newUpdatesForRuntimeVersion = newUpdates.filter(update => update.runtimeVersion === runtime.runtimeVersion);
                if (newUpdatesForRuntimeVersion.length === 0) {
                    throw new Error(`Publish response is missing updates with runtime ${runtime.runtimeVersion}.`);
                }
                const platforms = newUpdatesForRuntimeVersion.map(update => update.platform);
                const newAndroidUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'android');
                const newIosUpdate = newUpdatesForRuntimeVersion.find(update => update.platform === 'ios');
                const updateGroupId = newUpdatesForRuntimeVersion[0].group;
                const projectName = exp.slug;
                const accountName = (await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId)).name;
                const updateGroupUrl = (0, url_1.getUpdateGroupUrl)(accountName, projectName, updateGroupId);
                const updateGroupLink = (0, log_1.link)(updateGroupUrl, { dim: false });
                log_1.default.log((0, formatFields_1.default)([
                    { label: 'Branch', value: branchName },
                    { label: 'Runtime version', value: runtime.runtimeVersion },
                    { label: 'Platform', value: platforms.join(', ') },
                    { label: 'Update group ID', value: updateGroupId },
                    ...(newAndroidUpdate
                        ? [{ label: 'Android update ID', value: newAndroidUpdate.id }]
                        : []),
                    ...(newIosUpdate ? [{ label: 'iOS update ID', value: newIosUpdate.id }] : []),
                    { label: 'Message', value: updateMessage ?? '' },
                    ...(gitCommitHash
                        ? [
                            {
                                label: 'Commit',
                                value: `${gitCommitHash}${isGitWorkingTreeDirty ? '*' : ''}`,
                            },
                        ]
                        : []),
                    { label: 'EAS Dashboard', value: updateGroupLink },
                ]));
                log_1.default.addNewLineIfNone();
            }
        }
    }
    async publishRollbacksAsync({ graphqlClient, isGitWorkingTreeDirty, gitCommitHash, updateMessage, branchId, codeSigningInfo, runtimeVersions, realizedPlatforms, }) {
        const runtimeToPlatformMapping = (0, publish_1.getRuntimeToPlatformMappingFromRuntimeVersions)(runtimeVersions);
        const rollbackInfoGroups = Object.fromEntries(realizedPlatforms.map(platform => [platform, true]));
        // Sort the updates into different groups based on their platform specific runtime versions
        const updateGroups = runtimeToPlatformMapping.map(({ runtimeVersion, platforms }) => {
            const localRollbackInfoGroup = Object.fromEntries(platforms.map(platform => [platform, rollbackInfoGroups[platform]]));
            return {
                branchId,
                rollBackToEmbeddedInfoGroup: localRollbackInfoGroup,
                runtimeVersion,
                message: updateMessage,
                gitCommitHash,
                isGitWorkingTreeDirty,
                awaitingCodeSigningInfo: !!codeSigningInfo,
            };
        });
        const newUpdates = await PublishMutation_1.PublishMutation.publishUpdateGroupAsync(graphqlClient, updateGroups);
        if (codeSigningInfo) {
            log_1.default.log('ðŸ”’ Signing roll back');
            const updatesTemp = [...newUpdates];
            const updateGroupsAndTheirUpdates = updateGroups.map(updateGroup => {
                const newUpdates = updatesTemp.splice(0, Object.keys((0, nullthrows_1.default)(updateGroup.rollBackToEmbeddedInfoGroup)).length);
                return {
                    updateGroup,
                    newUpdates,
                };
            });
            await Promise.all(updateGroupsAndTheirUpdates.map(async ({ newUpdates }) => {
                await Promise.all(newUpdates.map(async (newUpdate) => {
                    const response = await (0, fetch_1.default)(newUpdate.manifestPermalink, {
                        method: 'GET',
                        headers: { accept: 'multipart/mixed' },
                    });
                    const directiveBody = (0, nullthrows_1.default)(await (0, code_signing_1.getDirectiveBodyAsync)(response));
                    (0, code_signing_1.checkDirectiveBodyAgainstUpdateInfoGroup)(directiveBody);
                    const directiveSignature = (0, code_signing_1.signBody)(directiveBody, codeSigningInfo);
                    await PublishMutation_1.PublishMutation.setCodeSigningInfoAsync(graphqlClient, newUpdate.id, {
                        alg: codeSigningInfo.codeSigningMetadata.alg,
                        keyid: codeSigningInfo.codeSigningMetadata.keyid,
                        sig: directiveSignature,
                    });
                }));
            }));
        }
        return newUpdates;
    }
    sanitizeFlags(flags) {
        const nonInteractive = flags['non-interactive'] ?? false;
        const { auto, branch: branchName, channel: channelName, message: updateMessage } = flags;
        if (nonInteractive && !auto && !(updateMessage && (branchName || channelName))) {
            core_1.Errors.error('--branch and --message, or --channel and --message are required when updating in non-interactive mode unless --auto is specified', { exit: 1 });
        }
        return {
            auto,
            branchName,
            channelName,
            updateMessage,
            platform: flags.platform,
            privateKeyPath: flags['private-key-path'],
            nonInteractive,
            json: flags.json ?? false,
        };
    }
}
_a = UpdateRollBackToEmbedded;
UpdateRollBackToEmbedded.description = 'roll back to the embedded update';
UpdateRollBackToEmbedded.flags = {
    branch: core_1.Flags.string({
        description: 'Branch to publish the rollback to embedded update group on',
        required: false,
    }),
    channel: core_1.Flags.string({
        description: 'Channel that the published rollback to embedded update should affect',
        required: false,
    }),
    message: core_1.Flags.string({
        description: 'A short message describing the rollback to embedded update',
        required: false,
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: [
            // TODO: Add web when it's fully supported
            ...publish_1.defaultPublishPlatforms,
            'all',
        ],
        default: 'all',
        required: false,
    }),
    auto: core_1.Flags.boolean({
        description: 'Use the current git branch and commit message for the EAS branch and update message',
        default: false,
    }),
    'private-key-path': core_1.Flags.string({
        description: `File containing the PEM-encoded private key corresponding to the certificate in expo-updates' configuration. Defaults to a file named "private-key.pem" in the certificate's directory.`,
        required: false,
    }),
    ...flags_1.EasNonInteractiveAndJsonFlags,
};
UpdateRollBackToEmbedded.contextDefinition = {
    ..._a.ContextOptions.DynamicProjectConfig,
    ..._a.ContextOptions.LoggedIn,
    ..._a.ContextOptions.Vcs,
};
exports.default = UpdateRollBackToEmbedded;
