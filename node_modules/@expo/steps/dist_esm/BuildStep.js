import assert from 'assert';
import fs from 'fs/promises';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { makeBuildStepInputByIdMap } from './BuildStepInput.js';
import { BuildStepOutput, makeBuildStepOutputByIdMap, } from './BuildStepOutput.js';
import { BIN_PATH } from './utils/shell/bin.js';
import { getDefaultShell, getShellCommandAndArgs } from './utils/shell/command.js';
import { cleanUpStepTemporaryDirectoriesAsync, createTemporaryEnvsDirectoryAsync, createTemporaryOutputsDirectoryAsync, saveScriptToTemporaryFileAsync, } from './BuildTemporaryFiles.js';
import { spawnAsync } from './utils/shell/spawn.js';
import { interpolateWithInputs } from './utils/template.js';
import { BuildStepRuntimeError } from './errors.js';
import { jsepEval } from './utils/jsepEval.js';
export var BuildStepStatus;
(function (BuildStepStatus) {
    BuildStepStatus["NEW"] = "new";
    BuildStepStatus["IN_PROGRESS"] = "in-progress";
    BuildStepStatus["SKIPPED"] = "skipped";
    BuildStepStatus["FAIL"] = "fail";
    BuildStepStatus["WARNING"] = "warning";
    BuildStepStatus["SUCCESS"] = "success";
})(BuildStepStatus || (BuildStepStatus = {}));
export var BuildStepLogMarker;
(function (BuildStepLogMarker) {
    BuildStepLogMarker["START_STEP"] = "start-step";
    BuildStepLogMarker["END_STEP"] = "end-step";
})(BuildStepLogMarker || (BuildStepLogMarker = {}));
// TODO: move to a place common with tests
const UUID_REGEX = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/;
export class BuildStepOutputAccessor {
    constructor(id, displayName, executed, outputById) {
        this.id = id;
        this.displayName = displayName;
        this.executed = executed;
        this.outputById = outputById;
    }
    getOutputValueByName(name) {
        if (!this.executed) {
            throw new BuildStepRuntimeError(`Failed getting output "${name}" from step "${this.displayName}". The step has not been executed yet.`);
        }
        if (!this.hasOutputParameter(name)) {
            throw new BuildStepRuntimeError(`Step "${this.displayName}" does not have output "${name}".`);
        }
        return this.outputById[name].value;
    }
    hasOutputParameter(name) {
        return name in this.outputById;
    }
    serialize() {
        return {
            id: this.id,
            executed: this.executed,
            outputById: Object.fromEntries(Object.entries(this.outputById).map(([key, value]) => [key, value.serialize()])),
            displayName: this.displayName,
        };
    }
    static deserialize(serialized) {
        const outputById = Object.fromEntries(Object.entries(serialized.outputById).map(([key, value]) => [
            key,
            BuildStepOutput.deserialize(value),
        ]));
        return new BuildStepOutputAccessor(serialized.id, serialized.displayName, serialized.executed, outputById);
    }
}
export class BuildStep extends BuildStepOutputAccessor {
    static getNewId(userDefinedId) {
        return userDefinedId !== null && userDefinedId !== void 0 ? userDefinedId : uuidv4();
    }
    static getDisplayName({ id, name, command, }) {
        if (name) {
            return name;
        }
        if (!id.match(UUID_REGEX)) {
            return id;
        }
        if (command) {
            const splits = command.trim().split('\n');
            for (const split of splits) {
                const trimmed = split.trim();
                if (trimmed && !trimmed.startsWith('#')) {
                    return trimmed;
                }
            }
        }
        return id;
    }
    constructor(ctx, { id, name, displayName, inputs, outputs, command, fn, workingDirectory: maybeWorkingDirectory, shell, supportedRuntimePlatforms: maybeSupportedRuntimePlatforms, env, ifCondition, }) {
        assert(command !== undefined || fn !== undefined, 'Either command or fn must be defined.');
        assert(!(command !== undefined && fn !== undefined), 'Command and fn cannot be both set.');
        const outputById = makeBuildStepOutputByIdMap(outputs);
        super(id, displayName, false, outputById);
        this.executed = false;
        this.id = id;
        this.name = name;
        this.displayName = displayName;
        this.supportedRuntimePlatforms = maybeSupportedRuntimePlatforms;
        this.inputs = inputs;
        this.outputs = outputs;
        this.inputById = makeBuildStepInputByIdMap(inputs);
        this.outputById = outputById;
        this.fn = fn;
        this.command = command;
        this.shell = shell !== null && shell !== void 0 ? shell : getDefaultShell();
        this.ifCondition = ifCondition;
        this.status = BuildStepStatus.NEW;
        this.internalId = uuidv4();
        const logger = ctx.baseLogger.child({
            buildStepInternalId: this.internalId,
            buildStepId: this.id,
            buildStepDisplayName: this.displayName,
        });
        this.ctx = ctx.stepCtx({ logger, relativeWorkingDirectory: maybeWorkingDirectory });
        this.stepEnvOverrides = env !== null && env !== void 0 ? env : {};
        ctx.registerStep(this);
    }
    async executeAsync() {
        try {
            this.ctx.logger.info({ marker: BuildStepLogMarker.START_STEP }, `Executing build step "${this.displayName}"`);
            this.status = BuildStepStatus.IN_PROGRESS;
            if (this.command !== undefined) {
                await this.executeCommandAsync();
            }
            else {
                await this.exectuteFnAsync();
            }
            this.ctx.logger.info({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.SUCCESS }, `Finished build step "${this.displayName}" successfully`);
            this.status = BuildStepStatus.SUCCESS;
        }
        catch (err) {
            this.ctx.logger.error({ err });
            this.ctx.logger.error({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.FAIL }, `Build step "${this.displayName}" failed`);
            this.status = BuildStepStatus.FAIL;
            throw err;
        }
        finally {
            this.executed = true;
        }
    }
    hasOutputParameter(name) {
        return name in this.outputById;
    }
    getOutputValueByName(name) {
        if (!this.executed) {
            throw new BuildStepRuntimeError(`Failed getting output "${name}" from step "${this.displayName}". The step has not been executed yet.`);
        }
        if (!this.hasOutputParameter(name)) {
            throw new BuildStepRuntimeError(`Step "${this.displayName}" does not have output "${name}".`);
        }
        return this.outputById[name].value;
    }
    canBeRunOnRuntimePlatform() {
        return (!this.supportedRuntimePlatforms ||
            this.supportedRuntimePlatforms.includes(this.ctx.global.runtimePlatform));
    }
    shouldExecuteStep(hasAnyPreviousStepsFailed) {
        var _a, _b;
        if (!this.ifCondition) {
            return !hasAnyPreviousStepsFailed;
        }
        let ifCondition = this.ifCondition;
        if (ifCondition.startsWith('${') && ifCondition.endsWith('}')) {
            ifCondition = ifCondition.slice(2, -1);
        }
        return Boolean(jsepEval(ifCondition, {
            success: () => !hasAnyPreviousStepsFailed,
            failure: () => hasAnyPreviousStepsFailed,
            always: () => true,
            never: () => false,
            env: this.effectiveEnv,
            inputs: (_b = (_a = this.inputs) === null || _a === void 0 ? void 0 : _a.reduce((acc, input) => {
                acc[input.id] = input.value;
                return acc;
            }, {})) !== null && _b !== void 0 ? _b : {},
            eas: {
                runtimePlatform: this.ctx.global.runtimePlatform,
                ...this.ctx.global.staticContext,
            },
        }));
    }
    skip() {
        this.status = BuildStepStatus.SKIPPED;
        this.ctx.logger.info({ marker: BuildStepLogMarker.START_STEP }, 'Executing build step "${this.displayName}"');
        this.ctx.logger.info(`Skipped build step "${this.displayName}"`);
        this.ctx.logger.info({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.SKIPPED }, `Skipped build step "${this.displayName}"`);
    }
    async executeCommandAsync() {
        assert(this.command, 'Command must be defined.');
        try {
            const command = this.interpolateInputsAndGlobalContextInTemplate(this.command, this.inputs);
            this.ctx.logger.debug(`Interpolated inputs in the command template`);
            const outputsDir = await createTemporaryOutputsDirectoryAsync(this.ctx.global, this.id);
            this.ctx.logger.debug(`Created temporary directory for step outputs: ${outputsDir}`);
            const envsDir = await createTemporaryEnvsDirectoryAsync(this.ctx.global, this.id);
            this.ctx.logger.debug(`Created temporary directory for step environment variables: ${outputsDir}`);
            const scriptPath = await saveScriptToTemporaryFileAsync(this.ctx.global, this.id, command);
            this.ctx.logger.debug(`Saved script to ${scriptPath}`);
            const { command: shellCommand, args } = getShellCommandAndArgs(this.shell, scriptPath);
            this.ctx.logger.debug(`Executing script: ${shellCommand}${args !== undefined ? ` ${args.join(' ')}` : ''}`);
            await spawnAsync(shellCommand, args !== null && args !== void 0 ? args : [], {
                cwd: this.ctx.workingDirectory,
                logger: this.ctx.logger,
                env: this.getScriptEnv({ outputsDir, envsDir }),
                // stdin is /dev/null, std{out,err} are piped into logger.
                stdio: ['ignore', 'pipe', 'pipe'],
            });
            this.ctx.logger.debug(`Script completed successfully`);
            await this.collectAndValidateOutputsAsync(outputsDir);
            await this.collectAndUpdateEnvsAsync(envsDir);
            this.ctx.logger.debug('Finished collecting output paramters');
        }
        finally {
            await cleanUpStepTemporaryDirectoriesAsync(this.ctx.global, this.id);
        }
    }
    async exectuteFnAsync() {
        assert(this.fn, 'Function (fn) must be defined');
        try {
            const outputsDir = await createTemporaryOutputsDirectoryAsync(this.ctx.global, this.id);
            this.ctx.logger.debug(`Created temporary directory for step outputs: ${outputsDir}`);
            const envsDir = await createTemporaryEnvsDirectoryAsync(this.ctx.global, this.id);
            this.ctx.logger.debug(`Created temporary directory for step environment variables: ${outputsDir}`);
            await this.fn(this.ctx, {
                inputs: this.inputById,
                outputs: this.outputById,
                env: this.getScriptEnv({ outputsDir, envsDir }),
            });
            this.ctx.logger.debug(`Script completed successfully`);
            await this.collectAndValidateOutputsAsync(outputsDir);
            await this.collectAndUpdateEnvsAsync(envsDir);
            this.ctx.logger.debug('Finished collecting output paramters');
        }
        finally {
            await cleanUpStepTemporaryDirectoriesAsync(this.ctx.global, this.id);
        }
    }
    interpolateInputsAndGlobalContextInTemplate(template, inputs) {
        if (!inputs) {
            return this.ctx.global.interpolate(template);
        }
        const vars = inputs.reduce((acc, input) => {
            var _a, _b;
            acc[input.id] =
                typeof input.value === 'object'
                    ? JSON.stringify(input.value)
                    : (_b = (_a = input.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
            return acc;
        }, {});
        const valueInterpolatedWithGlobalContext = this.ctx.global.interpolate(template);
        return interpolateWithInputs(valueInterpolatedWithGlobalContext, vars);
    }
    async collectAndValidateOutputsAsync(outputsDir) {
        var _a;
        const files = await fs.readdir(outputsDir);
        const nonDefinedOutputIds = [];
        for (const outputId of files) {
            if (!(outputId in this.outputById)) {
                nonDefinedOutputIds.push(outputId);
            }
            else {
                const file = path.join(outputsDir, outputId);
                const rawContents = await fs.readFile(file, 'utf-8');
                const value = rawContents.trim();
                this.outputById[outputId].set(value);
            }
        }
        if (nonDefinedOutputIds.length > 0) {
            const idsString = nonDefinedOutputIds.map((i) => `"${i}"`).join(', ');
            this.ctx.logger.warn(`Some outputs are not defined in step config: ${idsString}`);
        }
        const nonSetRequiredOutputIds = [];
        for (const output of (_a = this.outputs) !== null && _a !== void 0 ? _a : []) {
            try {
                const value = output.value;
                this.ctx.logger.debug(`Output parameter "${output.id}" is set to "${value}"`);
            }
            catch (err) {
                this.ctx.logger.debug({ err }, `Getting value for output parameter "${output.id}" failed.`);
                nonSetRequiredOutputIds.push(output.id);
            }
        }
        if (nonSetRequiredOutputIds.length > 0) {
            const idsString = nonSetRequiredOutputIds.map((i) => `"${i}"`).join(', ');
            throw new BuildStepRuntimeError(`Some required outputs have not been set: ${idsString}`, {
                metadata: { ids: nonSetRequiredOutputIds },
            });
        }
    }
    async collectAndUpdateEnvsAsync(envsDir) {
        const filenames = await fs.readdir(envsDir);
        const entries = await Promise.all(filenames.map(async (basename) => {
            const rawContents = await fs.readFile(path.join(envsDir, basename), 'utf-8');
            return [basename, rawContents];
        }));
        this.ctx.global.updateEnv({
            ...this.ctx.global.env,
            ...Object.fromEntries(entries),
        });
    }
    get effectiveEnv() {
        return { ...this.ctx.global.env, ...this.stepEnvOverrides };
    }
    getScriptEnv({ envsDir, outputsDir, }) {
        var _a;
        const env = this.effectiveEnv;
        const currentPath = (_a = env.PATH) !== null && _a !== void 0 ? _a : process.env.PATH;
        const newPath = currentPath ? `${BIN_PATH}:${currentPath}` : BIN_PATH;
        return {
            ...env,
            __EXPO_STEPS_OUTPUTS_DIR: outputsDir,
            __EXPO_STEPS_ENVS_DIR: envsDir,
            __EXPO_STEPS_WORKING_DIRECTORY: this.ctx.workingDirectory,
            PATH: newPath,
        };
    }
}
//# sourceMappingURL=BuildStep.js.map