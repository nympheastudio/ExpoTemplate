import assert from 'assert';
import { BuildStepGlobalContext } from './BuildStepContext.js';
import { BuildStepRuntimeError } from './errors.js';
import { BUILD_STEP_OR_BUILD_GLOBAL_CONTEXT_REFERENCE_REGEX, interpolateWithOutputs, } from './utils/template.js';
export var BuildStepInputValueTypeName;
(function (BuildStepInputValueTypeName) {
    BuildStepInputValueTypeName["STRING"] = "string";
    BuildStepInputValueTypeName["BOOLEAN"] = "boolean";
    BuildStepInputValueTypeName["NUMBER"] = "number";
    BuildStepInputValueTypeName["JSON"] = "json";
})(BuildStepInputValueTypeName || (BuildStepInputValueTypeName = {}));
export class BuildStepInput {
    static createProvider(params) {
        return (ctx, stepDisplayName) => new BuildStepInput(ctx, { ...params, stepDisplayName });
    }
    constructor(ctx, { id, stepDisplayName, allowedValues, defaultValue, required, allowedValueTypeName, }) {
        this.ctx = ctx;
        this.id = id;
        this.stepDisplayName = stepDisplayName;
        this.allowedValues = allowedValues;
        this.defaultValue = defaultValue;
        this.required = required;
        this.allowedValueTypeName = allowedValueTypeName;
    }
    get value() {
        var _a;
        const rawValue = (_a = this._value) !== null && _a !== void 0 ? _a : this.defaultValue;
        if (this.required && rawValue === undefined) {
            throw new BuildStepRuntimeError(`Input parameter "${this.id}" for step "${this.stepDisplayName}" is required but it was not set.`);
        }
        const valueDoesNotRequireInterpolation = rawValue === undefined || typeof rawValue === 'boolean' || typeof rawValue === 'number';
        let returnValue;
        if (valueDoesNotRequireInterpolation) {
            if (typeof rawValue !== this.allowedValueTypeName && rawValue !== undefined) {
                throw new BuildStepRuntimeError(`Input parameter "${this.id}" for step "${this.stepDisplayName}" must be of type "${this.allowedValueTypeName}".`);
            }
            returnValue = rawValue;
        }
        else {
            // `valueDoesNotRequireInterpolation` checks that `rawValue` is not undefined
            // so this will never be true.
            assert(rawValue !== undefined);
            const valueInterpolatedWithGlobalContext = this.ctx.interpolate(rawValue);
            const valueInterpolatedWithOutputsAndGlobalContext = interpolateWithOutputs(valueInterpolatedWithGlobalContext, (path) => { var _a; return (_a = this.ctx.getStepOutputValue(path)) !== null && _a !== void 0 ? _a : ''; });
            returnValue = this.parseInputValueToAllowedType(valueInterpolatedWithOutputsAndGlobalContext);
        }
        return this.fixEscapeCharacters(returnValue);
    }
    fixEscapeCharacters(input) {
        if (typeof input === 'string') {
            return input.replace(/\\n/g, '\n');
        }
        else if (typeof input === 'object') {
            for (const property of Object.keys(input)) {
                input[property] = this.fixEscapeCharacters(input[property]);
            }
            return input;
        }
        else {
            return input;
        }
    }
    get rawValue() {
        var _a;
        return (_a = this._value) !== null && _a !== void 0 ? _a : this.defaultValue;
    }
    set(value) {
        if (this.required && value === undefined) {
            throw new BuildStepRuntimeError(`Input parameter "${this.id}" for step "${this.stepDisplayName}" is required.`);
        }
        this._value = value;
        return this;
    }
    isValueOneOfAllowedValues() {
        var _a;
        const value = (_a = this._value) !== null && _a !== void 0 ? _a : this.defaultValue;
        if (this.allowedValues === undefined || value === undefined) {
            return true;
        }
        return this.allowedValues.includes(value);
    }
    isRawValueStepOrContextReference() {
        return (typeof this.rawValue === 'string' &&
            !!BUILD_STEP_OR_BUILD_GLOBAL_CONTEXT_REFERENCE_REGEX.exec(this.rawValue));
    }
    serialize() {
        return {
            id: this.id,
            stepDisplayName: this.stepDisplayName,
            defaultValue: this.defaultValue,
            allowedValues: this.allowedValues,
            allowedValueTypeName: this.allowedValueTypeName,
            required: this.required,
            value: this._value,
            ctx: this.ctx.serialize(),
        };
    }
    static deserialize(serializedInput, logger) {
        const deserializedContext = BuildStepGlobalContext.deserialize(serializedInput.ctx, logger);
        const input = new BuildStepInput(deserializedContext, {
            id: serializedInput.id,
            stepDisplayName: serializedInput.stepDisplayName,
            defaultValue: serializedInput.defaultValue,
            allowedValues: serializedInput.allowedValues,
            allowedValueTypeName: serializedInput.allowedValueTypeName,
            required: serializedInput.required,
        });
        input._value = serializedInput.value;
        return input;
    }
    parseInputValueToAllowedType(value) {
        if (typeof value === 'object') {
            return value;
        }
        if (this.allowedValueTypeName === BuildStepInputValueTypeName.STRING) {
            return value;
        }
        else if (this.allowedValueTypeName === BuildStepInputValueTypeName.NUMBER) {
            return this.parseInputValueToNumber(value);
        }
        else if (this.allowedValueTypeName === BuildStepInputValueTypeName.BOOLEAN) {
            return this.parseInputValueToBoolean(value);
        }
        else {
            return this.parseInputValueToObject(value);
        }
    }
    parseInputValueToNumber(value) {
        const numberValue = Number(value);
        if (Number.isNaN(numberValue)) {
            throw new BuildStepRuntimeError(`Input parameter "${this.id}" for step "${this.stepDisplayName}" must be of type "${this.allowedValueTypeName}".`);
        }
        return numberValue;
    }
    parseInputValueToBoolean(value) {
        if (value === 'true') {
            return true;
        }
        else if (value === 'false') {
            return false;
        }
        else {
            throw new BuildStepRuntimeError(`Input parameter "${this.id}" for step "${this.stepDisplayName}" must be of type "${this.allowedValueTypeName}".`);
        }
    }
    parseInputValueToObject(value) {
        try {
            return JSON.parse(value);
        }
        catch (e) {
            throw new BuildStepRuntimeError(`Input parameter "${this.id}" for step "${this.stepDisplayName}" must be of type "${this.allowedValueTypeName}".`, {
                cause: e,
            });
        }
    }
}
export function makeBuildStepInputByIdMap(inputs) {
    if (inputs === undefined) {
        return {};
    }
    return inputs.reduce((acc, input) => {
        acc[input.id] = input;
        return acc;
    }, {});
}
//# sourceMappingURL=BuildStepInput.js.map