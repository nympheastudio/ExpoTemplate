import assert from 'assert';
import { isBuildStepBareCommandRun, isBuildStepBareFunctionOrFunctionGroupCall, isBuildStepCommandRun, readAndValidateBuildConfigAsync, } from './BuildConfig.js';
import { BuildFunction } from './BuildFunction.js';
import { BuildStep } from './BuildStep.js';
import { BuildStepInput, BuildStepInputValueTypeName, } from './BuildStepInput.js';
import { BuildStepOutput } from './BuildStepOutput.js';
import { BuildWorkflow } from './BuildWorkflow.js';
import { BuildWorkflowValidator } from './BuildWorkflowValidator.js';
import { BuildConfigError } from './errors.js';
import { duplicates } from './utils/expodash/duplicates.js';
import { uniq } from './utils/expodash/uniq.js';
import { createBuildFunctionGroupByIdMapping, } from './BuildFunctionGroup.js';
export class BuildConfigParser {
    constructor(ctx, { configPath, externalFunctions, externalFunctionGroups, }) {
        this.ctx = ctx;
        this.validateExternalFunctions(externalFunctions);
        this.validateExternalFunctionGroups(externalFunctionGroups);
        this.configPath = configPath;
        this.externalFunctions = externalFunctions;
        this.externalFunctionGroups = externalFunctionGroups;
    }
    async parseAsync() {
        var _a;
        const config = await readAndValidateBuildConfigAsync(this.configPath, {
            externalFunctionIds: this.getExternalFunctionFullIds(),
            externalFunctionGroupsIds: this.getExternalFunctionGroupFullIds(),
        });
        const configBuildFunctions = this.createBuildFunctionsFromConfig(config.functions);
        const buildFunctions = this.mergeBuildFunctionsWithExternal(configBuildFunctions, this.externalFunctions);
        const buildFunctionGroups = createBuildFunctionGroupByIdMapping((_a = this.externalFunctionGroups) !== null && _a !== void 0 ? _a : []);
        const buildSteps = [];
        for (const stepConfig of config.build.steps) {
            buildSteps.push(...this.createBuildStepFromConfig(stepConfig, buildFunctions, buildFunctionGroups));
        }
        const workflow = new BuildWorkflow(this.ctx, { buildSteps, buildFunctions });
        await new BuildWorkflowValidator(workflow).validateAsync();
        return workflow;
    }
    createBuildStepFromConfig(buildStepConfig, buildFunctions, buildFunctionGroups) {
        if (isBuildStepCommandRun(buildStepConfig)) {
            return [this.createBuildStepFromBuildStepCommandRun(buildStepConfig)];
        }
        else if (isBuildStepBareCommandRun(buildStepConfig)) {
            return [this.createBuildStepFromBuildStepBareCommandRun(buildStepConfig)];
        }
        else if (isBuildStepBareFunctionOrFunctionGroupCall(buildStepConfig)) {
            return this.createBuildStepsFromBareBuildStepFunctionOrBareBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepConfig);
        }
        else if (buildStepConfig !== null) {
            return this.createBuildStepsFromBuildStepFunctionOrBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepConfig);
        }
        else {
            throw new BuildConfigError('Invalid build step configuration detected. Build step cannot be empty.');
        }
    }
    createBuildStepFromBuildStepCommandRun({ run }) {
        const { id: maybeId, inputs: inputsConfig, outputs: outputsConfig, name, workingDirectory, shell, command, env, if: ifCondition, } = run;
        const id = BuildStep.getNewId(maybeId);
        const displayName = BuildStep.getDisplayName({ id, name, command });
        const inputs = inputsConfig && this.createBuildStepInputsFromDefinition(inputsConfig, displayName);
        const outputs = outputsConfig && this.createBuildStepOutputsFromDefinition(outputsConfig, displayName);
        return new BuildStep(this.ctx, {
            id,
            inputs,
            outputs,
            name,
            displayName,
            workingDirectory,
            shell,
            command,
            env,
            ifCondition,
        });
    }
    createBuildStepFromBuildStepBareCommandRun({ run: command, }) {
        const id = BuildStep.getNewId();
        const displayName = BuildStep.getDisplayName({ id, command });
        return new BuildStep(this.ctx, {
            id,
            displayName,
            command,
        });
    }
    createBuildStepsFromBuildStepFunctionGroupCall(buildFunctionGroups, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const buildFunctionGroup = buildFunctionGroups[functionId];
        assert(buildFunctionGroup, `Build function group with id "${functionId}" is not defined.`);
        return buildFunctionGroup.createBuildStepsFromFunctionGroupCall(this.ctx, {
            callInputs: buildStepFunctionCall[functionId].inputs,
        });
    }
    createBuildStepsFromBuildStepBareFunctionGroupCall(buildFunctionGroups, functionGroupId) {
        const buildFunctionGroup = buildFunctionGroups[functionGroupId];
        assert(buildFunctionGroup, `Build function group with id "${functionGroupId}" is not defined.`);
        return buildFunctionGroup.createBuildStepsFromFunctionGroupCall(this.ctx);
    }
    createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionId) {
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx);
    }
    createBuildStepsFromBareBuildStepFunctionOrBareBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, functionOrFunctionGroupId) {
        const maybeFunctionGroup = buildFunctionGroups[functionOrFunctionGroupId];
        if (maybeFunctionGroup) {
            return this.createBuildStepsFromBuildStepBareFunctionGroupCall(buildFunctionGroups, functionOrFunctionGroupId);
        }
        return [
            this.createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionOrFunctionGroupId),
        ];
    }
    createBuildStepsFromBuildStepFunctionOrBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const maybeFunctionGroup = buildFunctionGroups[functionId];
        if (maybeFunctionGroup) {
            return this.createBuildStepsFromBuildStepFunctionGroupCall(buildFunctionGroups, buildStepFunctionCall);
        }
        return [this.createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall)];
    }
    createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const buildFunctionCallConfig = buildStepFunctionCall[functionId];
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx, {
            id: buildFunctionCallConfig.id,
            name: buildFunctionCallConfig.name,
            callInputs: buildFunctionCallConfig.inputs,
            workingDirectory: buildFunctionCallConfig.workingDirectory,
            shell: buildFunctionCallConfig.shell,
            env: buildFunctionCallConfig.env,
            ifCondition: buildFunctionCallConfig.if,
        });
    }
    createBuildFunctionsFromConfig(buildFunctionsConfig) {
        if (!buildFunctionsConfig) {
            return {};
        }
        const result = {};
        for (const [functionId, buildFunctionConfig] of Object.entries(buildFunctionsConfig)) {
            const buildFunction = this.createBuildFunctionFromConfig({
                id: functionId,
                ...buildFunctionConfig,
            });
            result[buildFunction.getFullId()] = buildFunction;
        }
        return result;
    }
    createBuildFunctionFromConfig({ id, name, inputs: inputsConfig, outputs: outputsConfig, shell, command, supportedRuntimePlatforms, path: customFunctionModulePath, }) {
        const inputProviders = inputsConfig && this.createBuildStepInputProvidersFromBuildFunctionInputs(inputsConfig);
        const outputProviders = outputsConfig && this.createBuildStepOutputProvidersFromBuildFunctionOutputs(outputsConfig);
        return new BuildFunction({
            id,
            name,
            inputProviders,
            outputProviders,
            shell,
            command,
            customFunctionModulePath,
            supportedRuntimePlatforms,
        });
    }
    createBuildStepInputsFromDefinition(buildStepInputs, stepDisplayName) {
        return Object.entries(buildStepInputs).map(([key, value]) => new BuildStepInput(this.ctx, {
            id: key,
            stepDisplayName,
            defaultValue: value,
            required: true,
            allowedValueTypeName: typeof value === 'object'
                ? BuildStepInputValueTypeName.JSON
                : typeof value,
        }));
    }
    createBuildStepInputProvidersFromBuildFunctionInputs(buildFunctionInputs) {
        return buildFunctionInputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepInput.createProvider({
                    id: entry,
                    required: true,
                    allowedValueTypeName: BuildStepInputValueTypeName.STRING,
                })
                : BuildStepInput.createProvider({
                    id: entry.name,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                    defaultValue: entry.defaultValue,
                    allowedValues: entry.allowedValues,
                    allowedValueTypeName: entry.allowedValueType,
                });
        });
    }
    createBuildStepOutputsFromDefinition(buildStepOutputs, stepDisplayName) {
        return buildStepOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? new BuildStepOutput(this.ctx, { id: entry, stepDisplayName, required: true })
                : new BuildStepOutput(this.ctx, {
                    id: entry.name,
                    stepDisplayName,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                });
        });
    }
    createBuildStepOutputProvidersFromBuildFunctionOutputs(buildFunctionOutputs) {
        return buildFunctionOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepOutput.createProvider({ id: entry, required: true })
                : BuildStepOutput.createProvider({ id: entry.name, required: (_a = entry.required) !== null && _a !== void 0 ? _a : true });
        });
    }
    mergeBuildFunctionsWithExternal(configFunctions, externalFunctions) {
        const result = { ...configFunctions };
        if (externalFunctions === undefined) {
            return result;
        }
        for (const buildFunction of externalFunctions) {
            // functions defined in config shadow the external ones
            const fullId = buildFunction.getFullId();
            if (!(fullId in result)) {
                result[fullId] = buildFunction;
            }
        }
        return result;
    }
    validateExternalFunctions(externalFunctions) {
        if (externalFunctions === undefined) {
            return;
        }
        const externalFunctionIds = externalFunctions.map((f) => f.getFullId());
        const duplicatedExternalFunctionIds = duplicates(externalFunctionIds);
        if (duplicatedExternalFunctionIds.length === 0) {
            return;
        }
        throw new BuildConfigError(`Provided external functions with duplicated IDs: ${duplicatedExternalFunctionIds
            .map((id) => `"${id}"`)
            .join(', ')}`);
    }
    validateExternalFunctionGroups(externalFunctionGroups) {
        if (externalFunctionGroups === undefined) {
            return;
        }
        const externalFunctionGroupIds = externalFunctionGroups.map((f) => f.getFullId());
        const duplicatedExternalFunctionGroupIds = duplicates(externalFunctionGroupIds);
        if (duplicatedExternalFunctionGroupIds.length === 0) {
            return;
        }
        throw new BuildConfigError(`Provided external function groups with duplicated IDs: ${duplicatedExternalFunctionGroupIds
            .map((id) => `"${id}"`)
            .join(', ')}`);
    }
    getExternalFunctionFullIds() {
        if (this.externalFunctions === undefined) {
            return [];
        }
        const ids = this.externalFunctions.map((f) => f.getFullId());
        return uniq(ids);
    }
    getExternalFunctionGroupFullIds() {
        if (this.externalFunctionGroups === undefined) {
            return [];
        }
        const ids = this.externalFunctionGroups.map((f) => f.getFullId());
        return uniq(ids);
    }
}
function getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall) {
    const keys = Object.keys(buildStepFunctionCall);
    assert(keys.length === 1, 'There must be at most one function call in the step (enforced by joi).');
    return keys[0];
}
//# sourceMappingURL=BuildConfigParser.js.map