"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildConfigParser = void 0;
const assert_1 = __importDefault(require("assert"));
const BuildConfig_js_1 = require("./BuildConfig.cjs");
const BuildFunction_js_1 = require("./BuildFunction.cjs");
const BuildStep_js_1 = require("./BuildStep.cjs");
const BuildStepInput_js_1 = require("./BuildStepInput.cjs");
const BuildStepOutput_js_1 = require("./BuildStepOutput.cjs");
const BuildWorkflow_js_1 = require("./BuildWorkflow.cjs");
const BuildWorkflowValidator_js_1 = require("./BuildWorkflowValidator.cjs");
const errors_js_1 = require("./errors.cjs");
const duplicates_js_1 = require("./utils/expodash/duplicates.cjs");
const uniq_js_1 = require("./utils/expodash/uniq.cjs");
const BuildFunctionGroup_js_1 = require("./BuildFunctionGroup.cjs");
class BuildConfigParser {
    constructor(ctx, { configPath, externalFunctions, externalFunctionGroups, }) {
        this.ctx = ctx;
        this.validateExternalFunctions(externalFunctions);
        this.validateExternalFunctionGroups(externalFunctionGroups);
        this.configPath = configPath;
        this.externalFunctions = externalFunctions;
        this.externalFunctionGroups = externalFunctionGroups;
    }
    async parseAsync() {
        var _a;
        const config = await (0, BuildConfig_js_1.readAndValidateBuildConfigAsync)(this.configPath, {
            externalFunctionIds: this.getExternalFunctionFullIds(),
            externalFunctionGroupsIds: this.getExternalFunctionGroupFullIds(),
        });
        const configBuildFunctions = this.createBuildFunctionsFromConfig(config.functions);
        const buildFunctions = this.mergeBuildFunctionsWithExternal(configBuildFunctions, this.externalFunctions);
        const buildFunctionGroups = (0, BuildFunctionGroup_js_1.createBuildFunctionGroupByIdMapping)((_a = this.externalFunctionGroups) !== null && _a !== void 0 ? _a : []);
        const buildSteps = [];
        for (const stepConfig of config.build.steps) {
            buildSteps.push(...this.createBuildStepFromConfig(stepConfig, buildFunctions, buildFunctionGroups));
        }
        const workflow = new BuildWorkflow_js_1.BuildWorkflow(this.ctx, { buildSteps, buildFunctions });
        await new BuildWorkflowValidator_js_1.BuildWorkflowValidator(workflow).validateAsync();
        return workflow;
    }
    createBuildStepFromConfig(buildStepConfig, buildFunctions, buildFunctionGroups) {
        if ((0, BuildConfig_js_1.isBuildStepCommandRun)(buildStepConfig)) {
            return [this.createBuildStepFromBuildStepCommandRun(buildStepConfig)];
        }
        else if ((0, BuildConfig_js_1.isBuildStepBareCommandRun)(buildStepConfig)) {
            return [this.createBuildStepFromBuildStepBareCommandRun(buildStepConfig)];
        }
        else if ((0, BuildConfig_js_1.isBuildStepBareFunctionOrFunctionGroupCall)(buildStepConfig)) {
            return this.createBuildStepsFromBareBuildStepFunctionOrBareBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepConfig);
        }
        else if (buildStepConfig !== null) {
            return this.createBuildStepsFromBuildStepFunctionOrBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepConfig);
        }
        else {
            throw new errors_js_1.BuildConfigError('Invalid build step configuration detected. Build step cannot be empty.');
        }
    }
    createBuildStepFromBuildStepCommandRun({ run }) {
        const { id: maybeId, inputs: inputsConfig, outputs: outputsConfig, name, workingDirectory, shell, command, env, if: ifCondition, } = run;
        const id = BuildStep_js_1.BuildStep.getNewId(maybeId);
        const displayName = BuildStep_js_1.BuildStep.getDisplayName({ id, name, command });
        const inputs = inputsConfig && this.createBuildStepInputsFromDefinition(inputsConfig, displayName);
        const outputs = outputsConfig && this.createBuildStepOutputsFromDefinition(outputsConfig, displayName);
        return new BuildStep_js_1.BuildStep(this.ctx, {
            id,
            inputs,
            outputs,
            name,
            displayName,
            workingDirectory,
            shell,
            command,
            env,
            ifCondition,
        });
    }
    createBuildStepFromBuildStepBareCommandRun({ run: command, }) {
        const id = BuildStep_js_1.BuildStep.getNewId();
        const displayName = BuildStep_js_1.BuildStep.getDisplayName({ id, command });
        return new BuildStep_js_1.BuildStep(this.ctx, {
            id,
            displayName,
            command,
        });
    }
    createBuildStepsFromBuildStepFunctionGroupCall(buildFunctionGroups, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const buildFunctionGroup = buildFunctionGroups[functionId];
        (0, assert_1.default)(buildFunctionGroup, `Build function group with id "${functionId}" is not defined.`);
        return buildFunctionGroup.createBuildStepsFromFunctionGroupCall(this.ctx, {
            callInputs: buildStepFunctionCall[functionId].inputs,
        });
    }
    createBuildStepsFromBuildStepBareFunctionGroupCall(buildFunctionGroups, functionGroupId) {
        const buildFunctionGroup = buildFunctionGroups[functionGroupId];
        (0, assert_1.default)(buildFunctionGroup, `Build function group with id "${functionGroupId}" is not defined.`);
        return buildFunctionGroup.createBuildStepsFromFunctionGroupCall(this.ctx);
    }
    createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionId) {
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx);
    }
    createBuildStepsFromBareBuildStepFunctionOrBareBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, functionOrFunctionGroupId) {
        const maybeFunctionGroup = buildFunctionGroups[functionOrFunctionGroupId];
        if (maybeFunctionGroup) {
            return this.createBuildStepsFromBuildStepBareFunctionGroupCall(buildFunctionGroups, functionOrFunctionGroupId);
        }
        return [
            this.createBuildStepFromBuildStepBareFunctionCall(buildFunctions, functionOrFunctionGroupId),
        ];
    }
    createBuildStepsFromBuildStepFunctionOrBuildStepFunctionGroupCall(buildFunctions, buildFunctionGroups, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const maybeFunctionGroup = buildFunctionGroups[functionId];
        if (maybeFunctionGroup) {
            return this.createBuildStepsFromBuildStepFunctionGroupCall(buildFunctionGroups, buildStepFunctionCall);
        }
        return [this.createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall)];
    }
    createBuildStepFromBuildStepFunctionCall(buildFunctions, buildStepFunctionCall) {
        const functionId = getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall);
        const buildFunctionCallConfig = buildStepFunctionCall[functionId];
        const buildFunction = buildFunctions[functionId];
        return buildFunction.createBuildStepFromFunctionCall(this.ctx, {
            id: buildFunctionCallConfig.id,
            name: buildFunctionCallConfig.name,
            callInputs: buildFunctionCallConfig.inputs,
            workingDirectory: buildFunctionCallConfig.workingDirectory,
            shell: buildFunctionCallConfig.shell,
            env: buildFunctionCallConfig.env,
            ifCondition: buildFunctionCallConfig.if,
        });
    }
    createBuildFunctionsFromConfig(buildFunctionsConfig) {
        if (!buildFunctionsConfig) {
            return {};
        }
        const result = {};
        for (const [functionId, buildFunctionConfig] of Object.entries(buildFunctionsConfig)) {
            const buildFunction = this.createBuildFunctionFromConfig({
                id: functionId,
                ...buildFunctionConfig,
            });
            result[buildFunction.getFullId()] = buildFunction;
        }
        return result;
    }
    createBuildFunctionFromConfig({ id, name, inputs: inputsConfig, outputs: outputsConfig, shell, command, supportedRuntimePlatforms, path: customFunctionModulePath, }) {
        const inputProviders = inputsConfig && this.createBuildStepInputProvidersFromBuildFunctionInputs(inputsConfig);
        const outputProviders = outputsConfig && this.createBuildStepOutputProvidersFromBuildFunctionOutputs(outputsConfig);
        return new BuildFunction_js_1.BuildFunction({
            id,
            name,
            inputProviders,
            outputProviders,
            shell,
            command,
            customFunctionModulePath,
            supportedRuntimePlatforms,
        });
    }
    createBuildStepInputsFromDefinition(buildStepInputs, stepDisplayName) {
        return Object.entries(buildStepInputs).map(([key, value]) => new BuildStepInput_js_1.BuildStepInput(this.ctx, {
            id: key,
            stepDisplayName,
            defaultValue: value,
            required: true,
            allowedValueTypeName: typeof value === 'object'
                ? BuildStepInput_js_1.BuildStepInputValueTypeName.JSON
                : typeof value,
        }));
    }
    createBuildStepInputProvidersFromBuildFunctionInputs(buildFunctionInputs) {
        return buildFunctionInputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepInput_js_1.BuildStepInput.createProvider({
                    id: entry,
                    required: true,
                    allowedValueTypeName: BuildStepInput_js_1.BuildStepInputValueTypeName.STRING,
                })
                : BuildStepInput_js_1.BuildStepInput.createProvider({
                    id: entry.name,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                    defaultValue: entry.defaultValue,
                    allowedValues: entry.allowedValues,
                    allowedValueTypeName: entry.allowedValueType,
                });
        });
    }
    createBuildStepOutputsFromDefinition(buildStepOutputs, stepDisplayName) {
        return buildStepOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? new BuildStepOutput_js_1.BuildStepOutput(this.ctx, { id: entry, stepDisplayName, required: true })
                : new BuildStepOutput_js_1.BuildStepOutput(this.ctx, {
                    id: entry.name,
                    stepDisplayName,
                    required: (_a = entry.required) !== null && _a !== void 0 ? _a : true,
                });
        });
    }
    createBuildStepOutputProvidersFromBuildFunctionOutputs(buildFunctionOutputs) {
        return buildFunctionOutputs.map((entry) => {
            var _a;
            return typeof entry === 'string'
                ? BuildStepOutput_js_1.BuildStepOutput.createProvider({ id: entry, required: true })
                : BuildStepOutput_js_1.BuildStepOutput.createProvider({ id: entry.name, required: (_a = entry.required) !== null && _a !== void 0 ? _a : true });
        });
    }
    mergeBuildFunctionsWithExternal(configFunctions, externalFunctions) {
        const result = { ...configFunctions };
        if (externalFunctions === undefined) {
            return result;
        }
        for (const buildFunction of externalFunctions) {
            // functions defined in config shadow the external ones
            const fullId = buildFunction.getFullId();
            if (!(fullId in result)) {
                result[fullId] = buildFunction;
            }
        }
        return result;
    }
    validateExternalFunctions(externalFunctions) {
        if (externalFunctions === undefined) {
            return;
        }
        const externalFunctionIds = externalFunctions.map((f) => f.getFullId());
        const duplicatedExternalFunctionIds = (0, duplicates_js_1.duplicates)(externalFunctionIds);
        if (duplicatedExternalFunctionIds.length === 0) {
            return;
        }
        throw new errors_js_1.BuildConfigError(`Provided external functions with duplicated IDs: ${duplicatedExternalFunctionIds
            .map((id) => `"${id}"`)
            .join(', ')}`);
    }
    validateExternalFunctionGroups(externalFunctionGroups) {
        if (externalFunctionGroups === undefined) {
            return;
        }
        const externalFunctionGroupIds = externalFunctionGroups.map((f) => f.getFullId());
        const duplicatedExternalFunctionGroupIds = (0, duplicates_js_1.duplicates)(externalFunctionGroupIds);
        if (duplicatedExternalFunctionGroupIds.length === 0) {
            return;
        }
        throw new errors_js_1.BuildConfigError(`Provided external function groups with duplicated IDs: ${duplicatedExternalFunctionGroupIds
            .map((id) => `"${id}"`)
            .join(', ')}`);
    }
    getExternalFunctionFullIds() {
        if (this.externalFunctions === undefined) {
            return [];
        }
        const ids = this.externalFunctions.map((f) => f.getFullId());
        return (0, uniq_js_1.uniq)(ids);
    }
    getExternalFunctionGroupFullIds() {
        if (this.externalFunctionGroups === undefined) {
            return [];
        }
        const ids = this.externalFunctionGroups.map((f) => f.getFullId());
        return (0, uniq_js_1.uniq)(ids);
    }
}
exports.BuildConfigParser = BuildConfigParser;
function getFunctionIdFromBuildStepFunctionCall(buildStepFunctionCall) {
    const keys = Object.keys(buildStepFunctionCall);
    (0, assert_1.default)(keys.length === 1, 'There must be at most one function call in the step (enforced by joi).');
    return keys[0];
}
//# sourceMappingURL=BuildConfigParser.js.map